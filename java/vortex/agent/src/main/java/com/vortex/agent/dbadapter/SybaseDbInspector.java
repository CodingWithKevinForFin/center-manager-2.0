package com.vortex.agent.dbadapter;import java.math.BigDecimal;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.sql.Timestamp;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import com.f1.base.Row;import com.f1.base.Table;import com.f1.utils.CH;import com.f1.utils.DBH;import com.f1.utils.IOH;import com.f1.utils.LH;import com.f1.utils.PropertyController;import com.f1.utils.SH;import com.f1.utils.structs.Tuple2;import com.f1.vortexcommon.msg.agent.VortexAgentDbColumn;import com.f1.vortexcommon.msg.agent.VortexAgentDbDatabase;import com.f1.vortexcommon.msg.agent.VortexAgentDbObject;import com.f1.vortexcommon.msg.agent.VortexAgentDbPrivilege;import com.f1.vortexcommon.msg.agent.VortexAgentDbTable;public class SybaseDbInspector extends DbInspector {	private static String DRIVER_NAME = "sybase.driver.name";	private static String URI = "sybase.uri";	private static String USER_NAME = "sybase.username";	private static String PASSWD = "sybase.password";	private static String MASTER_DB = "sybase.db.name";	private void processDatabase(Connection connection, VortexAgentDbDatabase agentDbDatabase, String schemaName) throws SQLException {		StringBuilder sink = new StringBuilder();		Map<String, Timestamp> timestampsByTables = new HashMap<String, Timestamp>();		Table creationDates = exec(connection, "select name, crdate from sysobjects");		for (Row row : creationDates.getRows()) {			String name = row.get("name", String.class);			Timestamp createdTime = row.get("crdate", Timestamp.class);			if (createdTime != null)				timestampsByTables.put(name, createdTime);		}		// TABLE_TYPE,ENGINE		Map<String, VortexAgentDbTable> dbTables = agentDbDatabase.getTables();		SH.clear(sink).append("sp_tables");		Table tables = exec(connection, sink.toString());		for (Row row : tables.getRows()) {			String name = row.get("table_name", String.class);			String comment = row.get("remarks", String.class);			VortexAgentDbTable tb = nw(VortexAgentDbTable.class);			tb.setName(name);			tb.setColumns(new HashMap<String, VortexAgentDbColumn>());			if (comment != null)				tb.setComments(comment);			Timestamp createdTime = timestampsByTables.get(name);			if (createdTime != null)				tb.setCreateTime(createdTime.getTime());			tb.setDescription("Type " + row.get("table_type", String.class));			dbTables.put(name, tb);		}		SH.clear(sink).append("sp_columns null,null,null,null");		Table columns = exec(connection, sink.toString());		for (Row row : columns.getRows()) {			String tableName = row.get("table_name", String.class);			VortexAgentDbDatabase db = agentDbDatabase;			VortexAgentDbTable tb = db.getTables().get(tableName);			if (tb == null) {				LH.info(log, "table not found for column: ", row);				continue;			}			String colName = row.get("column_name", String.class);			String comments = row.get("remarks", String.class);			Map<String, VortexAgentDbColumn> dbCols = tb.getColumns();			VortexAgentDbColumn cl = nw(VortexAgentDbColumn.class);			String columnType = row.get("type_name", String.class);			// cl.setPosition(row.get("ORDINAL_POSITION", Integer.class));			byte mask = 0;			if ("YES".equals(row.get("is_nullable", String.class)))				mask |= VortexAgentDbColumn.MASK_NULLABLE;			if (columnType.startsWith("unsigned"))				mask |= VortexAgentDbColumn.MASK_UNSIGNED;			cl.setMask(mask);			BigDecimal precision = row.get("precision", BigDecimal.class);			if (precision != null)				cl.setPrecision(precision.shortValue());			BigDecimal scale = row.get("scale", BigDecimal.class);			if (scale != null)				cl.setScale(scale.shortValue());			cl.setName(colName);			// Short size = row.get("CHARACTER_MAXIMUM_LENGTH", Short.class);			// if (size != null)			// cl.setSize(size);			Tuple2<Byte, Long> type = null;			String dataType = row.get("type_name", String.class);			type = DATA_TYPES.get(dataType);			if (type == null)				type = DATA_TYPES.get("OTHER");			cl.setType(type.getA());			if (type.getB() != null)				cl.setSize(type.getB());			if (cl.getType() == VortexAgentDbColumn.TYPE_ENUM || cl.getType() == VortexAgentDbColumn.TYPE_SET) {				String[] parts = SH.split(',', SH.beforeLast(SH.afterFirst(columnType, '('), ')'));				Set s = new HashSet<String>();				for (String part : parts)					s.add(SH.trim('\'', part));				cl.setPermissibleValues(SH.join(',', CH.sort(s)));			}			if (comments != null)				cl.setComments(comments);			cl.setDescription("DataType " + dataType);			dbCols.put(colName, cl);		}		Table results = exec(				connection,				"select tr.name as name, tbl.instrig, tbl.updtrig, tbl.deltrig from sysobjects tbl, sysobjects tr where tbl.type='U' and tr.type='TR' and (tbl.instrig=tr.id or tbl.updtrig=tr.id or tbl.deltrig=tr.id )");		for (Row row : results.getRows()) {			String ins = row.get("instrig", String.class);			String upd = row.get("updtrig", String.class);			String del = row.get("deltrig", String.class);			StringBuilder builder = new StringBuilder();			if (ins != null)				builder.append("InsertTrigger");			if (upd != null)				builder.append(" UpdateTrigger");			if (del != null)				builder.append(" DeleteTrigger");			String name = row.get("name", String.class);			String definition = builder.toString();			VortexAgentDbObject def = nw(VortexAgentDbObject.class);			if (definition.length() > 0)				def.setDefinition(definition);			def.setName(name);			def.setType((byte) 2);			agentDbDatabase.getObjects().add(def);		}		results = exec(connection, "select name from sysobjects where type='P' or type='XP'");		for (Row row : results.getRows()) {			String name = row.get("name", String.class);			//				String definition = builder.toString();			VortexAgentDbObject def = nw(VortexAgentDbObject.class);			//				if(definition.length() > 0)			//					def.setDefinition(definition);			def.setName(name);			def.setType((byte) 1);			agentDbDatabase.getObjects().add(def);		}		results = exec(connection, "select name from sysobjects where type='RI'");		for (Row row : results.getRows()) {			String name = row.get("name", String.class);			//				String definition = builder.toString();			VortexAgentDbObject def = nw(VortexAgentDbObject.class);			//				if(definition.length() > 0)			//					def.setDefinition(definition);			def.setName(name);			def.setType((byte) 3);			agentDbDatabase.getObjects().add(def);		}		for (String table : dbTables.keySet()) {			Table privileges = null;			try {				SH.clear(sink).append("sp_table_privileges ").append(table);				privileges = exec(connection, sink.toString());			}			catch (Exception e) {				LH.info(log, e.getMessage() + "tableName ", table);				continue;			}			for (Row row : privileges.getRows()) {				String user = row.get("grantee", String.class);				String privilege = row.get("privilege", String.class);				Integer type = PRIV_TYPES.get(privilege);				VortexAgentDbPrivilege pr = nw(VortexAgentDbPrivilege.class);				pr.setUser(user);				if (table != null)					pr.setTableName(table);				if (type == null) {					type = PRIV_TYPES.get("OTHER");					pr.setDescription("PRIVILEGE " + privilege);				}				pr.setType(pr.getType() | type);				agentDbDatabase.getPrivileges().add(pr);			}		}	}	public Map<String, VortexAgentDbDatabase> inspectDatabase(Connection connection) throws SQLException {		Map<String, VortexAgentDbDatabase> r = new HashMap<String, VortexAgentDbDatabase>();		StringBuilder sink = new StringBuilder();		Map<String, Timestamp> timestampsByTables = new HashMap<String, Timestamp>();		Statement stmt = connection.createStatement();		StringBuilder builder = new StringBuilder();		try {			SH.clear(sink).append("sp_databases");			Table schemas = exec(connection, sink.toString());			for (Row row : schemas.getRows()) {				String name = row.get("database_name", String.class);				VortexAgentDbDatabase db = nw(VortexAgentDbDatabase.class);				db.setName(name);				db.setTables(new HashMap<String, VortexAgentDbTable>());				db.setObjects(new ArrayList<VortexAgentDbObject>());				db.setPrivileges(new ArrayList<VortexAgentDbPrivilege>());				r.put(name, db);				stmt.execute(SH.clear(builder).append("use ").append(name).toString());				processDatabase(connection, db, name);			}			// TODO - is it captured?			/*			SH.clear(sink).append("sp_helprotect");			Table<Row> privileges = exec(connection, sink.toString());
			Map<Tuple3<String, String, String>, AgentDbPrivilege> m = new HashMap<Tuple3<String, String, String>, AgentDbPrivilege>();			for (Row row : privileges.getRows()) {				String user = row.get("grantee", String.class);				String schema = row.get("object", String.class);				String privilege = row.get("action", String.class);				Integer type = PRIV_TYPES.get(privilege);				Tuple3<String, String, String> k = new Tuple3<String, String, String>(user, schema, null);				AgentDbPrivilege pr = m.get(k);				if (pr == null) {					pr = nw(AgentDbPrivilege.class);					pr.setUser(user);					m.put(k, pr);				}				if (type == null) {					type = PRIV_TYPES.get("OTHER");					pr.setDescription("PRIVILEGE " + privilege);				}				pr.setType(pr.getType() | type);			}			for (Entry<Tuple3<String, String, String>, AgentDbPrivilege> e : m.entrySet()) {				String schema = e.getKey().getB();				AgentDbDatabase db = r.get(schema);				if (db == null) {					db = nw(AgentDbDatabase.class);					db.setName(schema);					db.setTables(new HashMap<String, AgentDbTable>());					db.setObjects(new ArrayList<AgentDbObject>());					db.setPrivileges(new ArrayList<AgentDbPrivilege>());					r.put(schema, db);				}				db.getPrivileges().add(e.getValue());			} */		} finally {			IOH.close(connection);		}		return r;	}	static final Map<String, Tuple2<Byte, Long>> DATA_TYPES = new HashMap<String, Tuple2<Byte, Long>>();	static final Map<String, Integer> PRIV_TYPES = new HashMap<String, Integer>();	public static final String ID = "Sybase";	static {		DATA_TYPES.put("tinyint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 1L));		DATA_TYPES.put("smallint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 2L));		DATA_TYPES.put("mediumint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 3L));		DATA_TYPES.put("int", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 4L));		DATA_TYPES.put("integer", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 4L));		DATA_TYPES.put("bigint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 8L));		DATA_TYPES.put("float", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 4L));		DATA_TYPES.put("double", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 8L));		DATA_TYPES.put("double precision", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 8L));		DATA_TYPES.put("real", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 8L));		DATA_TYPES.put("decimal", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FIXEDPOINT, null));		DATA_TYPES.put("numeric", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FIXEDPOINT, null));		DATA_TYPES.put("date", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATE, 3L));		DATA_TYPES.put("datetime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATETIME, 8L));		DATA_TYPES.put("bigdatetime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATETIME, 8L));		DATA_TYPES.put("smalldatetime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATETIME, 8L));		DATA_TYPES.put("timestamp", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_TIMESTAMP, 8L));		DATA_TYPES.put("time", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_TIME, 8L));		DATA_TYPES.put("bigtime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_TIME, 8L));		DATA_TYPES.put("year", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_YEAR, 1L));		DATA_TYPES.put("char", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_CHAR, null));		DATA_TYPES.put("varchar", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_VARCHAR, null));		DATA_TYPES.put("tinyblock", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 8 - 1));		DATA_TYPES.put("tinytext", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 8 - 1));		DATA_TYPES.put("blob", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_VARCHAR, 1L << 16 - 1));		DATA_TYPES.put("text", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 16 - 1));		DATA_TYPES.put("mediumblob", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 24 - 1));		DATA_TYPES.put("mediumtext", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 24 - 1));		DATA_TYPES.put("longblob", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 32 - 1));		DATA_TYPES.put("longtext", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 32 - 1));		DATA_TYPES.put("enum", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_SET, null));		DATA_TYPES.put("set", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_ENUM, null));		DATA_TYPES.put("OTHER", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_OTHER, null));		PRIV_TYPES.put("ALTER", VortexAgentDbPrivilege.ALTER);		PRIV_TYPES.put("ALTER ROUTINE", VortexAgentDbPrivilege.ALTER_ROUTINE);		PRIV_TYPES.put("CREATE", VortexAgentDbPrivilege.CREATE);		PRIV_TYPES.put("CREATE ROUTINE", VortexAgentDbPrivilege.CREATE_ROUTINE);		PRIV_TYPES.put("CREATE TEMPORARY TABLES", VortexAgentDbPrivilege.CREATE_TEMP_TABLES);		PRIV_TYPES.put("CREATE VIEW", VortexAgentDbPrivilege.CREATE_VIEW);		PRIV_TYPES.put("DELETE", VortexAgentDbPrivilege.DELETE);		PRIV_TYPES.put("EXECUTE", VortexAgentDbPrivilege.EXECUTE);		PRIV_TYPES.put("DROP", VortexAgentDbPrivilege.DROP);		PRIV_TYPES.put("EVENT", VortexAgentDbPrivilege.EVENT);		PRIV_TYPES.put("INDEX", VortexAgentDbPrivilege.INDEX);		PRIV_TYPES.put("INSERT", VortexAgentDbPrivilege.INSERT);		PRIV_TYPES.put("LOCK TABLES", VortexAgentDbPrivilege.LOCK_TABLES);		PRIV_TYPES.put("REFERENCES", VortexAgentDbPrivilege.REFERENCES);		PRIV_TYPES.put("SELECT", VortexAgentDbPrivilege.SELECT);		PRIV_TYPES.put("SHOW VIEW", VortexAgentDbPrivilege.SHOW_VIEW);		PRIV_TYPES.put("TRIGGER", VortexAgentDbPrivilege.TRIGGER);		PRIV_TYPES.put("UPDATE", VortexAgentDbPrivilege.UPDATE);		PRIV_TYPES.put("OTHER", VortexAgentDbPrivilege.OTHER);	}	private Table exec(Connection connection, String sql) throws SQLException {		return (Table) DBH.toTable(connection.prepareStatement(sql).executeQuery());	}	public static Connection getConnection(PropertyController props) {		try {			String driverName = props.getRequired(DRIVER_NAME);			Class.forName(driverName);			String dbName = props.getRequired(MASTER_DB);			String user = props.getRequired(USER_NAME);			String pwd = props.getRequired(PASSWD);			return DriverManager.getConnection(getURI(dbName), user, pwd);		}		catch (Exception sqlEx) {			sqlEx.printStackTrace();		}		return null;	}	private static String getURI(String dbName) {		StringBuilder builder = new StringBuilder();		builder.append(URI).append("/").append(dbName);		return builder.toString();	}}