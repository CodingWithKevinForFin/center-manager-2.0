package com.vortex.agent.dbadapter;import java.math.BigDecimal;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;import java.sql.Timestamp;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;import com.f1.base.Row;import com.f1.base.Table;import com.f1.utils.CH;import com.f1.utils.DBH;import com.f1.utils.IOH;import com.f1.utils.LH;import com.f1.utils.PropertyController;import com.f1.utils.SH;import com.f1.utils.structs.Tuple2;import com.f1.vortexcommon.msg.agent.VortexAgentDbColumn;import com.f1.vortexcommon.msg.agent.VortexAgentDbDatabase;import com.f1.vortexcommon.msg.agent.VortexAgentDbObject;import com.f1.vortexcommon.msg.agent.VortexAgentDbPrivilege;import com.f1.vortexcommon.msg.agent.VortexAgentDbTable;public class MsSqlServerDbInspector extends DbInspector {	private static String DRIVER_NAME = "mssql.driver.name";	private static String URI = "mssql.uri";	private static String USER_NAME = "mssql.username";	private static String PASSWD = "mssql.password";	private static String MASTER_DB = "mssql.db.name";	private void processDatabase(Connection connection, VortexAgentDbDatabase agentDbDatabase, String schemaName) throws SQLException {		StringBuilder sink = new StringBuilder();		Map<String, Timestamp> timestampsByTables = new HashMap<String, Timestamp>();		Table creationDates = exec(connection, "select name, crdate from sysobjects");		for (Row row : creationDates.getRows()) {			String name = row.get("name", String.class);			Timestamp createdTime = row.get("crdate", Timestamp.class);			if (createdTime != null)				timestampsByTables.put(name, createdTime);		}		// TABLE_TYPE,ENGINE		Map<String, VortexAgentDbTable> dbTables = agentDbDatabase.getTables();		SH.clear(sink).append("sp_tables");		Table tables = exec(connection, sink.toString());		for (Row row : tables.getRows()) {			if ("VIEW".equals(row.get("TABLE_TYPE", String.class)))				continue;			String name = row.get("TABLE_NAME", String.class);			String comment = row.get("REMARKS", String.class);			VortexAgentDbTable tb = nw(VortexAgentDbTable.class);			tb.setName(name);			tb.setColumns(new HashMap<String, VortexAgentDbColumn>());			if (comment != null)				tb.setComments(comment);			Timestamp createdTime = timestampsByTables.get(name);			if (createdTime != null)				tb.setCreateTime(createdTime.getTime());			tb.setDescription("Type " + row.get("TABLE_TYPE", String.class));			dbTables.put(name, tb);		}		/*				Map<String, VortexAgentDbTable> dbTables1 = agentDbDatabase.getTables();				SH.clear(sink).append("select * from sys.objects where type in ('FN','IF','TF')");				Table<Row> tables1 = exec(connection, sink.toString());				for (Row row : tables1.getRows()) {					String name = row.get("name", String.class);					VortexAgentDbTable tb = nw(VortexAgentDbTable.class);					tb.setName(name);					tb.setColumns(new HashMap<String, VortexAgentDbColumn>());					Timestamp createdTime = timestampsByTables.get(name);					if (createdTime != null)						tb.setCreateTime(createdTime.getTime());					tb.setDescription("Type " + row.get("type_desc", String.class));					dbTables.put(name, tb);				}		*/		SH.clear(sink).append("sp_columns null,null,null,null");		Table columns = exec(connection, sink.toString());		for (Row row : columns.getRows()) {			String tableName = row.get("TABLE_NAME", String.class);			String tableOwner = row.get("TABLE_OWNER", String.class);			VortexAgentDbDatabase db = agentDbDatabase;			VortexAgentDbTable tb = db.getTables().get(tableName);			if (tb == null) {				//	if ("sys".equals(tableOwner) == false)				//	LH.info(log, "table not found for column: ", row);				continue;			}			String colName = row.get("COLUMN_NAME", String.class);			String comments = row.get("REMARKS", String.class);			Map<String, VortexAgentDbColumn> dbCols = tb.getColumns();			VortexAgentDbColumn cl = nw(VortexAgentDbColumn.class);			String columnType = row.get("TYPE_NAME", String.class);			byte mask = 0;			if ("YES".equals(row.get("IS_NULLABLE", String.class)))				mask |= VortexAgentDbColumn.MASK_NULLABLE;			if (columnType.startsWith("unsigned"))				mask |= VortexAgentDbColumn.MASK_UNSIGNED;			cl.setMask(mask);			BigDecimal precision = row.get("PRECISION", BigDecimal.class);			BigDecimal scale = row.get("SCALE", BigDecimal.class);			BigDecimal length = row.get("LENGTH", BigDecimal.class);			if (scale != null)				cl.setScale(scale.shortValue());			cl.setName(colName);			Tuple2<Byte, Long> type = null;			String dataType = row.get("TYPE_NAME", String.class);			type = DATA_TYPES.get(dataType);			if (type == null)				type = DATA_TYPES.get("OTHER");			cl.setType(type.getA());			if (VortexAgentDbColumn.TYPE_VARCHAR == cl.getType() || VortexAgentDbColumn.TYPE_BLOB == cl.getType()) {				cl.setSize(precision.longValue());				cl.setPrecision((short) 0);			} else if ("sysname".equals(dataType) || "image".equals(dataType) || "varbinary".equals(dataType) || "binary".equals(dataType)) {				cl.setSize(length.longValue());				cl.setPrecision((short) 0);			} else if ("nchar".equals(dataType)) {				cl.setSize(precision.longValue());				cl.setPrecision((short) 0);			} else {				if (type.getB() != null)					cl.setSize(type.getB());				if (precision != null)					cl.setPrecision(precision.shortValue());			}			if (cl.getType() == VortexAgentDbColumn.TYPE_ENUM || cl.getType() == VortexAgentDbColumn.TYPE_SET) {				String[] parts = SH.split(',', SH.beforeLast(SH.afterFirst(columnType, '('), ')'));				Set s = new HashSet<String>();				for (String part : parts)					s.add(SH.trim('\'', part));				cl.setPermissibleValues(SH.join(',', CH.sort(s)));			}			if (comments != null)				cl.setComments(comments);			cl.setDescription("DataType " + dataType);			dbCols.put(colName, cl);		}		Table results = exec(				connection,				"select tr.name as name, tbl.instrig, tbl.updtrig, tbl.deltrig from sysobjects tbl, sysobjects tr where tbl.type='U' and tr.type='TR' and (tbl.instrig=tr.id or tbl.updtrig=tr.id or tbl.deltrig=tr.id )");		for (Row row : results.getRows()) {			String ins = row.get("instrig", String.class);			String upd = row.get("updtrig", String.class);			String del = row.get("deltrig", String.class);			StringBuilder builder = new StringBuilder();			if (ins != null)				builder.append("InsertTrigger");			if (upd != null)				builder.append(" UpdateTrigger");			if (del != null)				builder.append(" DeleteTrigger");			String name = row.get("name", String.class);			String definition = builder.toString();			VortexAgentDbObject def = nw(VortexAgentDbObject.class);			if (definition.length() > 0)				def.setDefinition(definition);			def.setName(name);			def.setType((byte) 2);			agentDbDatabase.getObjects().add(def);		}		results = exec(connection, "select name from sysobjects where type='P' or type='XP'");		for (Row row : results.getRows()) {			String name = row.get("name", String.class);			VortexAgentDbObject def = nw(VortexAgentDbObject.class);			def.setName(name);			def.setType((byte) 1);			agentDbDatabase.getObjects().add(def);		}		results = exec(connection, "select name from sysobjects where type='RI'");		for (Row row : results.getRows()) {			String name = row.get("name", String.class);			VortexAgentDbObject def = nw(VortexAgentDbObject.class);			def.setName(name);			def.setType((byte) 3);			agentDbDatabase.getObjects().add(def);		}		for (String table : dbTables.keySet()) {			Table privileges = null;			try {				SH.clear(sink).append("sp_table_privileges ").append(table);				privileges = exec(connection, sink.toString());			} catch (Exception e) {				LH.info(log, e.getMessage(), "tableName ", table);				continue;			}			for (Row row : privileges.getRows()) {				String user = row.get("GRANTEE", String.class);				String privilege = row.get("PRIVILEGE", String.class);				Integer type = PRIV_TYPES.get(privilege);				VortexAgentDbPrivilege pr = nw(VortexAgentDbPrivilege.class);				pr.setUser(user);				if (table != null)					pr.setTableName(table);				if (type == null) {					type = PRIV_TYPES.get("OTHER");					pr.setDescription("PRIVILEGE " + privilege);				}				pr.setType(pr.getType() | type);				agentDbDatabase.getPrivileges().add(pr);			}		}	}	public Map<String, VortexAgentDbDatabase> inspectDatabase(Connection connection) throws SQLException {		Map<String, VortexAgentDbDatabase> r = new HashMap<String, VortexAgentDbDatabase>();		StringBuilder sink = new StringBuilder();		Map<String, Timestamp> timestampsByTables = new HashMap<String, Timestamp>();		Statement stmt = connection.createStatement();		StringBuilder builder = new StringBuilder();		try {			SH.clear(sink).append("sp_databases");			Table schemas = exec(connection, sink.toString());			for (Row row : schemas.getRows()) {				String name = row.get("DATABASE_NAME", String.class);				VortexAgentDbDatabase db = nw(VortexAgentDbDatabase.class);				db.setName(name);				db.setTables(new HashMap<String, VortexAgentDbTable>());				db.setObjects(new ArrayList<VortexAgentDbObject>());				db.setPrivileges(new ArrayList<VortexAgentDbPrivilege>());				r.put(name, db);				stmt.execute(SH.clear(builder).append("use ").append(name).toString());				processDatabase(connection, db, name);			}		} finally {			IOH.close(connection);		}		return r;	}	static final Map<String, Tuple2<Byte, Long>> DATA_TYPES = new HashMap<String, Tuple2<Byte, Long>>();	static final Map<String, Integer> PRIV_TYPES = new HashMap<String, Integer>();	public static final String ID = "MsSqlServer";	static {		DATA_TYPES.put("bit", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BOOLEAN, 1L));		DATA_TYPES.put("tinyint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 1L));		DATA_TYPES.put("smallint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 2L));		DATA_TYPES.put("mediumint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 3L));		DATA_TYPES.put("int", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 4L));		DATA_TYPES.put("integer", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 4L));		DATA_TYPES.put("bigint", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_INT, 8L));		DATA_TYPES.put("float", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 4L));		DATA_TYPES.put("double", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 8L));		DATA_TYPES.put("double precision", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 8L));		DATA_TYPES.put("real", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FLOAT, 8L));		DATA_TYPES.put("decimal", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FIXEDPOINT, null));		DATA_TYPES.put("numeric", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_FIXEDPOINT, null));		DATA_TYPES.put("date", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATE, 3L));		DATA_TYPES.put("datetime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATETIME, 8L));		DATA_TYPES.put("bigdatetime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATETIME, 8L));		DATA_TYPES.put("smalldatetime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_DATETIME, 8L));		DATA_TYPES.put("timestamp", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_TIMESTAMP, 8L));		DATA_TYPES.put("time", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_TIME, 8L));		DATA_TYPES.put("bigtime", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_TIME, 8L));		DATA_TYPES.put("year", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_YEAR, 1L));		DATA_TYPES.put("char", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_CHAR, null));		DATA_TYPES.put("nchar", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_CHAR, null));		DATA_TYPES.put("varchar", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_VARCHAR, null));		DATA_TYPES.put("nvarchar", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_VARCHAR, null));		DATA_TYPES.put("ntext", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, null));		DATA_TYPES.put("tinyblock", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 8 - 1));		DATA_TYPES.put("tinytext", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 8 - 1));		DATA_TYPES.put("blob", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 16 - 1));		DATA_TYPES.put("text", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 16 - 1));		DATA_TYPES.put("mediumblob", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 24 - 1));		DATA_TYPES.put("mediumtext", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 24 - 1));		DATA_TYPES.put("longblob", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 32 - 1));		DATA_TYPES.put("longtext", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_BLOB, 1L << 32 - 1));		DATA_TYPES.put("enum", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_SET, null));		DATA_TYPES.put("set", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_ENUM, null));		DATA_TYPES.put("OTHER", new Tuple2<Byte, Long>(VortexAgentDbColumn.TYPE_OTHER, null));		PRIV_TYPES.put("ALTER", VortexAgentDbPrivilege.ALTER);		PRIV_TYPES.put("ALTER ROUTINE", VortexAgentDbPrivilege.ALTER_ROUTINE);		PRIV_TYPES.put("CREATE", VortexAgentDbPrivilege.CREATE);		PRIV_TYPES.put("CREATE ROUTINE", VortexAgentDbPrivilege.CREATE_ROUTINE);		PRIV_TYPES.put("CREATE TEMPORARY TABLES", VortexAgentDbPrivilege.CREATE_TEMP_TABLES);		PRIV_TYPES.put("CREATE VIEW", VortexAgentDbPrivilege.CREATE_VIEW);		PRIV_TYPES.put("DELETE", VortexAgentDbPrivilege.DELETE);		PRIV_TYPES.put("EXECUTE", VortexAgentDbPrivilege.EXECUTE);		PRIV_TYPES.put("DROP", VortexAgentDbPrivilege.DROP);		PRIV_TYPES.put("EVENT", VortexAgentDbPrivilege.EVENT);		PRIV_TYPES.put("INDEX", VortexAgentDbPrivilege.INDEX);		PRIV_TYPES.put("INSERT", VortexAgentDbPrivilege.INSERT);		PRIV_TYPES.put("LOCK TABLES", VortexAgentDbPrivilege.LOCK_TABLES);		PRIV_TYPES.put("REFERENCES", VortexAgentDbPrivilege.REFERENCES);		PRIV_TYPES.put("SELECT", VortexAgentDbPrivilege.SELECT);		PRIV_TYPES.put("SHOW VIEW", VortexAgentDbPrivilege.SHOW_VIEW);		PRIV_TYPES.put("TRIGGER", VortexAgentDbPrivilege.TRIGGER);		PRIV_TYPES.put("UPDATE", VortexAgentDbPrivilege.UPDATE);		PRIV_TYPES.put("OTHER", VortexAgentDbPrivilege.OTHER);	}	private Table exec(Connection connection, String sql) throws SQLException {		return DBH.toTable(connection.prepareStatement(sql).executeQuery());	}	public static Connection getConnection(PropertyController props) {		try {			String driverName = props.getRequired(DRIVER_NAME);			String user = props.getRequired(USER_NAME);			String pwd = props.getRequired(PASSWD);			Class.forName(driverName);			return DriverManager.getConnection(URI, user, pwd);		} catch (Exception sqlEx) {			sqlEx.printStackTrace();		}		return null;	}}
