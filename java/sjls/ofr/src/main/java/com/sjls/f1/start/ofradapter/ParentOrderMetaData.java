package com.sjls.f1.start.ofradapter;

import java.util.TimerTask;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.log4j.Logger;

import com.f1.pofo.oms.OmsAction;
import com.f1.pofo.oms.OmsClientAction;
import com.f1.pofo.oms.Order;
import com.sjls.algos.eo.common.AlertMsg;
import com.sjls.algos.eo.common.AlertMsg.AlertLevel;
import com.sjls.algos.eo.common.OrderStatus;

public class ParentOrderMetaData {
    public static String CVS_ID = "$Id: ParentOrderMetaData.java,v 1.1.1.1 2014/02/07 20:55:02 olu Exp $";
    public final static Logger m_logger = Logger.getLogger(ParentOrderMetaData.class);
    
    private final String blockID;
    private volatile TimerTask poCxlTimeoutTask;
    private volatile OmsAction omsState;
    private final OfrAdapter m_adapter;
    private final ConcurrentHashMap<OmsSliceId, OmsSlice> m_omsSlices = new ConcurrentHashMap<OmsSliceId, OmsSlice>();
    
    public ParentOrderMetaData(final OfrAdapter adapater, final String blockID) {
        m_adapter = adapater;
        this.blockID = blockID;
    }
    
    /** returns true if the OMS_STATE == CANCEL_ORDER */
    public boolean isPendingCancel() {
        return omsState == OmsAction.CANCEL_ORDER;
    }


    public OmsAction getOMSState() { return omsState; }
    
    public void scheduleCancelTimeout(final int cxlorderTimeoutSecs) {
        poCxlTimeoutTask = new TimerTask() {
            public void run() {
                try {
                    if(isPendingCancel())  { //still in CANCEL_ORDER state!
                        m_logger.error(String.format("BlockID=[%s]. ParentOrder Cancel Attempt Timed out! " + 
                                "Will now FORCE CANCELLATION OF ALL CHILD ORDERS and ALSO SEND a U-R-Out back to the BUYSIDE", blockID));
                        final OmsClientAction response = m_adapter.getOmsClientActionGenerator().nw();
                        response.setRootOrderID(blockID);
                        response.setOrderID(blockID);
                        response.setOrderAction(OmsAction.CANCEL_ALL_CHILD_ORDERS);
                        response.setText("OFR Cancel Attempt Timed out. So, 1st we cancel ALL oustanding slices");
                        scheduleUROut(10); //TODO: U-R-Out scheduled for 10 secs. Hard-coded
                        poCxlTimeoutTask = null; //task has run, so set to null for completeness.
                        sendToOMS(response); //Note. We dont alter the Parent Order OMS state!!
                    }
                }
                catch(Exception e) {
                    m_logger.error(getMessage(e), e);
                }
            }
        };
        m_adapter.getTimer().schedule(poCxlTimeoutTask, cxlorderTimeoutSecs*1000); //Scheduled
        if(m_logger.isDebugEnabled()) {
            m_logger.debug(String.format("BlockID=[%s]: Parent order cancel Timeout scheduled to run in %s seconds!", blockID, cxlorderTimeoutSecs));
        }
    }

    protected void scheduleUROut(final int urOutSecs) {
        m_adapter.getTimer().schedule(
                new TimerTask() {
                    public void run() {
                        try {
                            final OmsClientAction response = m_adapter.getOmsClientActionGenerator().nw();
                            response.setRootOrderID(blockID);
                            response.setOrderID(blockID);
                            response.setOrderAction(OmsAction.ORDER_CANCELLED);
                            response.setText("Autogenerated U-R-Out because OFR Cancel Attempt Timed out");
                            setOMSState(response.getOrderAction()).sendToOMS(response);                               
                        }
                        catch(Exception e) {
                            m_logger.error(getMessage(e), e);
                        }
                    }
                }, 
                urOutSecs*1000);
        m_logger.error(String.format("BlockID=[%s]: U-R-Out scheduled to be sent to BUYSIDE in %s seconds!", blockID, urOutSecs));
    }

    
    public void doDefferedOMSOrderCxldNotification(final OmsClientAction action) {
        final TimerTask task = new TimerTask() {
            @Override
            public void run() {
                try {
                    if(getLeavesQty() > 0) {
                        m_logger.info(String.format("BlockID=[%s]. Block is PendingCancel and LeavesQty=[%d]...waiting for leavesQty to be zero before giving OUT to client",
                                blockID, getLeavesQty()));
                    }
                    else {
                        action.setOrderAction(OmsAction.ORDER_CANCELLED);
                        storeAndForwardToOMS(action);
                        cancel(); //stop checking!
                    }
                }
                catch(Exception e) {
                    m_logger.error(e.getMessage(), e);
                }
            }
        };
        m_adapter.getTimer().scheduleAtFixedRate(task, 1*1000, 5*1000); //Initial delay of 1sec, subsequent delay of 5 secs
    }

    
    
    public ParentOrderMetaData setOMSState(final OmsAction omsAction) {
        final OmsAction prevAction = omsState;
        omsState = omsAction;
        m_logger.info(String.format("BlockID=[%s], Set Order state to Action=[%s]. PreviousAction=[%s]", blockID, omsAction, prevAction));
        return this;
    }

    public void sendToOMS(final OmsClientAction clientAction) {
        if(clientAction != null) {
            final String blockID=clientAction.getRootOrderID();
            final OmsAction omsAction = clientAction.getOrderAction();
            m_logger.info(String.format("Responding to OMS: BlockID=[%s], Action=[%s]. Text=[%s]", blockID, omsAction, clientAction.getText()));
            m_adapter.toOms.send(clientAction, null);
            // Send an alert to CP
            if(clientAction.getOrderAction() == OmsAction.REJECT_ORDER) {
                final AlertMsg alertMsg = new AlertMsg(AlertLevel.ERROR, blockID, clientAction.getText());
                m_adapter.onControlPanelAlert(alertMsg);
            }
        }            
    }

    
    public void cancelCxlTimeoutTask() {
        if(poCxlTimeoutTask != null) {
            poCxlTimeoutTask.cancel();
            poCxlTimeoutTask = null;
            m_logger.info(String.format("BlockID=[%s], OFR POCancelTimeout Task has been cancelled", blockID));
        }
    }

    
    private void storeAndForwardToOMS(final OmsClientAction clientAction) {
        if(clientAction != null) {
            setOMSState(clientAction.getOrderAction()).sendToOMS(clientAction);
        }
    }

    
    private final static String getMessage(final Exception e) {
        return (e==null|| e.getMessage()==null) ? "NullPointer" : e.getMessage();
    }

    
    static class OmsSlice {
        private final OmsSliceId sliceID;
        private final int orderQty;
        private int cumQty;
        private OrderStatus status;

        public OmsSlice(final OmsSliceId id, final int qty, final OrderStatus ordStatus) {
            sliceID = id;
            orderQty = qty;
            status = ordStatus;
        }
        
        public int getCumQty() {
            return cumQty;
        }
        public void setCumQty(final int cumQty) {
            this.cumQty = cumQty;
            if(cumQty <= 0) {
                setStatus(OrderStatus.New);
            }
            else if(cumQty >= orderQty) {
                setStatus(OrderStatus.Filled);
            }
            else {
                setStatus(OrderStatus.PartiallyFilled);
            }
        }

        public OrderStatus getStatus() {
            return status;
        }
        public void setStatus(final OrderStatus status) {
            this.status = status;
        }

        public int getOrderQty() {
            return orderQty;
        }
        
        public OmsSliceId getSliceId() {
            return sliceID;
        }
        
        public int getLeavesQty() {
            switch(status) {
            case Canceled:
            case Rejected:
                return 0;
            default:
                return orderQty - cumQty;
            }
        }
        
        @Override
        public String toString() {
            return String.format("SliceID:[%s], OrderQty=[%d], CumQty=[%d], Status=[%s]", sliceID, orderQty, cumQty, status);
        }
    }


    public void onNewSlice(final OmsSliceId omsID, final Order order) {
        final OmsSlice omsSlice = new OmsSlice(omsID, order.getOrderQty(), OrderStatus.New);
        m_omsSlices.put(omsSlice.getSliceId(), omsSlice);
        if(m_logger.isDebugEnabled()) m_logger.debug(String.format("onNewSlice(): BlockID=[%s] OMSSlice==>[%s]", getBlockId(), omsSlice));
    }

    public void onSliceModified(final OmsSliceId omsID, final Order order) {
        final OmsSlice prevSlice = m_omsSlices.get(omsID);
        if(prevSlice == null) {
            m_logger.error(String.format("Cannot locate prevSlice for omsID [%s]. Modify notification is [%s]", omsID, order));
        }
        else {
            final OmsSlice omsSlice = new OmsSlice(omsID, order.getOrderQty(), prevSlice.getStatus());
            omsSlice.setCumQty(order.getTotalExecQty());
            m_omsSlices.put(omsSlice.getSliceId(), omsSlice);
            if(m_logger.isDebugEnabled()) m_logger.debug(String.format("onSliceModified(): BlockID=[%s] OMSSlice==>[%s]", getBlockId(), omsSlice));
        }
    }

    public void onExecution(final OmsSliceId omsID, final Order order) {
        final OmsSlice omsSlice = m_omsSlices.get(omsID);
        if(omsSlice == null) {
            m_logger.error(String.format("Cannot locate prevSlice for omsID [%s]. Modify notification is [%s]", omsID, order));
        }
        else {
            omsSlice.setCumQty(order.getTotalExecQty());
            if(m_logger.isDebugEnabled()) m_logger.debug(String.format("onExecution(): BlockID=[%s] OMSSlice==>[%s]", getBlockId(), omsSlice));
        }
    }

    
    public void onSliceCanceled(final OmsSliceId omsID, final Order order) {
        final OmsSlice omsSlice = m_omsSlices.get(omsID);
        if(omsSlice == null) {
            m_logger.error(String.format("Cannot locate prevSlice for omsID [%s]. Modify notification is [%s]", omsID, order));
        }
        else {
            omsSlice.setStatus(OrderStatus.Canceled);
            if(m_logger.isDebugEnabled()) m_logger.debug(String.format("onSliceCanceled(): BlockID=[%s] OMSSlice==>[%s]", getBlockId(), omsSlice));
        }        
    }

    public void onSliceRejected(final OmsSliceId omsID, final Order order) {
        final OmsSlice omsSlice = m_omsSlices.get(omsID);
        if(omsSlice == null) {
            m_logger.error(String.format("Cannot locate prevSlice for omsID [%s]. Modify notification is [%s]", omsID, order));
        }
        else {
            omsSlice.setStatus(OrderStatus.Rejected);
            if(m_logger.isDebugEnabled()) m_logger.debug(String.format("onSliceRejected(): BlockID=[%s] OMSSlice==>[%s]", getBlockId(), omsSlice));
        }                
    }

    public String getBlockId() {
        return blockID;
    }

    
    public int getLeavesQty() {
        int lvsQty = 0;
        for (OmsSlice slice : m_omsSlices.values()) {
            lvsQty += slice.getLeavesQty();
        }
        return lvsQty;
    }

}
