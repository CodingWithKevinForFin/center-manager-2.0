package com.sjls.f1.start.ofradapter;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Timer;import java.util.concurrent.ConcurrentHashMap;import org.apache.log4j.Logger;import com.f1.ami.client.AmiClient;import com.f1.ami.client.AmiClientCommandDef;import com.f1.ami.client.AmiClientListener;import com.f1.base.DateNanos;import com.f1.base.ObjectGeneratorForClass;import com.f1.container.OutputPort;import com.f1.container.RequestOutputPort;import com.f1.container.ResultMessage;import com.f1.container.impl.AbstractConnectable;import com.f1.fixomsclient.OmsClientNotification;import com.f1.fixomsclient.OmsClientOrdersExecutions;import com.f1.fixomsclient.OmsClientOrdersExecutionsListener;import com.f1.fixomsclient.OmsClientOrdersExecutionsManager;import com.f1.pofo.fix.OrdStatus;import com.f1.pofo.oms.ChildNewOrderRequest;import com.f1.pofo.oms.ChildOrderRequest;import com.f1.pofo.oms.ExecInstruction;import com.f1.pofo.oms.Execution;import com.f1.pofo.oms.OmsAction;import com.f1.pofo.oms.OmsClientAction;import com.f1.pofo.oms.Order;import com.f1.pofo.oms.OrderType;import com.f1.pofo.oms.Side;import com.f1.pofo.oms.SliceType;import com.f1.pofo.refdata.Security;import com.f1.povo.standard.MapMessage;import com.f1.povo.standard.TextMessage;import com.f1.utils.CH;import com.f1.utils.OH;import com.f1.utils.SH;import com.f1.utils.VH;import com.f1.utils.mutable.Mutable;import com.f1.utils.mutable.Mutable.Int;import com.google.protobuf.Message;import com.sjls.algos.eo.common.AlertMsg;import com.sjls.algos.eo.common.AlgoParamsIS;import com.sjls.algos.eo.common.AlgoPrice;import com.sjls.algos.eo.common.AmendOrderRequestMsg;import com.sjls.algos.eo.common.EOException;import com.sjls.algos.eo.common.IBinStatistics;import com.sjls.algos.eo.common.IEMSServices;import com.sjls.algos.eo.common.IExecutionOptimizer;import com.sjls.algos.eo.common.INewOrderRequestMsg;import com.sjls.algos.eo.common.IParentOrderEvent;import com.sjls.algos.eo.common.IParentOrderStatusUpdateMsg;import com.sjls.algos.eo.common.IParentOrderStatusUpdateMsg.UpdateType;import com.sjls.algos.eo.common.IQuoteData;import com.sjls.algos.eo.common.IStrategyUpdateMsg;import com.sjls.algos.eo.common.ITickData;import com.sjls.algos.eo.common.ITradeData;import com.sjls.algos.eo.common.LimitPrice;import com.sjls.algos.eo.common.OrderModifyException;import com.sjls.algos.eo.common.PrimaryMarket;import com.sjls.algos.eo.common.QueryKey;import com.sjls.algos.eo.common.StrategyUpdateMsg;import com.sjls.algos.eo.core.PSStockFile;import com.sjls.algos.eo.core.PSStockFile.Rec;import com.sjls.controlpanel.protobuf.io.ICPInstance;import com.sjls.controlpanel.protobuf.io.IControPanelMsgListener;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.CPAlertLevel;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.CPAlertMsg;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.CPAlgoParams;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.CPCommandMsg;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.CPStatus;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.CmdResponseMsg;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.SJLSTime;import com.sjls.controlpanel.protobuf.messages.ControlPanelMsgs.SaveAllocationCmdMsg;import com.sjls.controlpanel.protobuf.utils.ProtobufUtils;import com.sjls.f1.start.ofr.IMarketDataListener;import com.sjls.f1.start.ofr.IMarketDataManager;import com.sjls.f1.start.ofr.brokeralloc.BrokerAllocMgr;import com.sjls.f1.start.ofr.controlpanel.BlockOrder;import com.sjls.f1.start.ofr.controlpanel.CPImage;import com.sjls.f1.start.ofr.controlpanel.CPServer;import com.sjls.f1.start.ofradapter.OfrSliceMetadataMap.SliceMetadata;import com.sjls.start.common.SJLSCustomTags;public class OfrAdapter extends AbstractConnectable implements OmsClientOrdersExecutionsListener, IControPanelMsgListener, IEMSServices, IMarketDataListener, AmiClientListener {	public static String CVS_ID = "$Id: OfrAdapter.java,v 1.16 2014/12/03 17:45:40 olu Exp $";	private static int m_routeToBrokerTag = SJLSCustomTags.ROUTE_TO_BROKERID_TAG;	private static String m_routeToBrokerIgnoreValue;	public final static Logger m_logger = Logger.getLogger(OfrAdapter.class);	private final static int CXLORDER_TIMEOUT_SECS = 60; //1 minute. TODO: Put this in root.properties	private volatile boolean SHORT_SELL_CAPABLE = true;	private volatile IExecutionOptimizer m_eo;	private ObjectGeneratorForClass<OmsClientAction> oa;	private ObjectGeneratorForClass<ChildNewOrderRequest> cr;	private ObjectGeneratorForClass<ChildOrderRequest> ar;	private OMSConnectionHandler omsProxy;	private final Map<String, ParentOrderMetaData> m_cachedParentOrders = new ConcurrentHashMap<String, ParentOrderMetaData>();	final public RequestOutputPort<OmsClientAction, TextMessage> toOmsRequestPort = newRequestOutputPort(OmsClientAction.class, TextMessage.class);	final public OutputPort<OmsClientAction> toOms = newOutputPort(OmsClientAction.class);	private Map<String, Integer> m_priorFilledQuantity = new HashMap<String, Integer>();	/** Used to store certain OFR slice properties */	private OfrSliceMetadataMap m_ofrSliceMetadataMap = new OfrSliceMetadataMap();	//Need to dispatch parent order txns and child order events in separate thread partitions	//NOTE: We dont need the ATP anymore since OFR-3.X performs ParentOrder txns in the bkgd --Olu E. 02-10-2014	//final AffinityThreadPool poExecutor = new AffinityThreadPool(8);	final Timer m_timer = new Timer();	private volatile IMarketDataManager m_mktDataMgr;	private volatile PSStockFile m_secMaster;	private volatile BrokerAllocMgr m_brokerAllocMgr;	/** Set of BlockOrders....the way they should look in the Control Panel */	private final CPImage m_cpImage;	private final CPServer m_cpServer;	private HashMap<String, Mutable.Int> parentLeaves;	public OfrAdapter(final Integer cpPort) {		m_cpServer = new CPServer(cpPort, this);		m_cpImage = new CPImage(m_cpServer);		m_cpServer.setSnapshotProvider(m_cpImage);	}	public void setShortSellCapable(boolean b) {		SHORT_SELL_CAPABLE = b;	}	public void setExecutionOptimizer(IExecutionOptimizer eo) {		m_eo = eo;	}	public void setMarketDataManager(final IMarketDataManager md) {		if (m_logger.isDebugEnabled())			m_logger.debug("setMarketDataManager called");		m_mktDataMgr = md;	}	public void setSecMaster(final PSStockFile psStockFile) {		if (m_logger.isDebugEnabled())			m_logger.debug("setSecMaster called");		m_secMaster = psStockFile;	}	public void setBrokerAllocMgr(final BrokerAllocMgr brokerAllocMgr) {		if (m_logger.isDebugEnabled())			m_logger.debug("setBrokerAllocMgr() called");		m_brokerAllocMgr = brokerAllocMgr;		m_cpServer.setBrokerAllocMgr(brokerAllocMgr);	}	public void init() {		super.init();		initAmiClient();		oa = getGenerator(OmsClientAction.class);		cr = getGenerator(ChildNewOrderRequest.class);		ar = getGenerator(ChildOrderRequest.class);		this.parentLeaves = new HashMap<String, Mutable.Int>();	}	public void start() {		super.start();		//OH.sleep(20);		//		for (int i = 0; i < 100; i++)		//			new Thread() {		//				@Override		//				public void run() {		//					for (int i = 0; i < 1000000000; i++)		//						new Object().toString();		//		//				}		//			}.start();		if (m_logger.isDebugEnabled())			m_logger.debug("start called");		if (m_eo != null)			try {				m_eo.startWork();				m_cpServer.start();				m_timer.schedule(m_cpImage.getRefreshTask(), 5 * 1000/*Initial delay of 5 secs */, 1 * 1000/*Subsequent delay of 1 sec */				);				//				if (m_mktDataMgr == null) {					final SJLMktDataPump mktDataPump = new SJLMktDataPump(m_eo); //will send mkt data directly to EO					mktDataPump.startWork();					m_logger.info("Now pumping **FAKE** market data to OFR");				} else {					m_mktDataMgr.addListener(this);				}			} catch (EOException e) {				throw OH.toRuntime(e);			}	}	@Override	public void onNewOrder(final OmsClientOrdersExecutions manager, final Order order, final OmsAction action) {		createOrderMessage(order, action);		final String msgPrefix;		final String blockID;		if (order.getSliceType() == SliceType.SLICE) {			blockID = m_ofrSliceMetadataMap.getBlockId(new OmsSliceId(order.getId()));		} else {			blockID = order.getId();		}		//		if (order.getSymbolSfx() == null || order.getSymbolSfx().trim().length() == 0) {			msgPrefix = String.format("BlockID=[%s], %s: ", blockID, order.getSymbol());		} else {			msgPrefix = String.format("BlockID=[%s], %s/%s: ", blockID, order.getSymbol(), order.getSymbolSfx());		}		m_logger.info(msgPrefix + String.format("onNewOrder(): Got action [%s] from [%s]", action.name(), order.getSenderSubId()));		//		OmsClientAction response = null;		//		switch (action) {			case SNAPSHOT: // TODO: filter only parent orders will come in the snapshot				if (order.getSliceType() == SliceType.SLICE)					break; //We dont recover child orders				if (OrdStatus.isCompleted(order.getOrderStatus()))					break; // We dont recover completed orders				m_cpImage.onNewOrder(order);				response = oa.nw();				response.setRootOrderID(order.getId());				response.setOrderAction(OmsAction.CANCEL_ALL_CHILD_ORDERS);				storeAndForwardToOMS(response);				break;			case NEW_ORDER_RCVD: //New ParentOrder recvd				m_cpImage.onNewOrder(order);				response = oa.nw(); // Prepare response message				response.setRootOrderID(order.getId()); // Root Order ID is used to communicate what is the ultimate parent ID: Useful for threading           				response.setOrderID(order.getId()); // Order ID is to let the OMS know what order (parent or child) THIS action is for				//				final Security sec = omsProxy.getRefData(toSymbol(order)); // Validate with ref data and get system wide security ID registered with OMS				if (sec == null) {					response.setOrderAction(OmsAction.REJECT_ORDER); // Security is invalid according to central Security Master					response.setText("Invalid Symbol " + toSymbol(order));					m_logger.warn(msgPrefix + response.getText() + ", rejecting order: " + order);				} else if (order.getIDType() == 1 && cusipSame(order.getSecurityID(), sec.getCusip())) {					if (order.getSide().equals(Side.SHORT_SELL) && !SHORT_SELL_CAPABLE) {						response.setOrderAction(OmsAction.REJECT_ORDER);						response.setText("Client unable to send correct short sell order: " + order.getSymbol());						m_logger.warn(msgPrefix + response.getText() + ", rejecting order: " + order);					} else {						final Rec rec = m_secMaster.findStockRecByCusip(sec.getCusip());						final PrimaryMarket primaryMkt = rec == null ? null : rec.getPrimaryMkt();						if (primaryMkt == null) {							response.setOrderAction(OmsAction.REJECT_ORDER);							response.setText(String.format("Cannot determine PRIMARY market for this order ==>[%s]<==. CUSIP=[%s]. Order Rejected", order, sec.getCusip()));							m_logger.error(msgPrefix + response.getText());						} else {							try {								if (m_mktDataMgr != null)									m_mktDataMgr.subscribe(sec.getSymbol(), sec.getRic(), primaryMkt); // primaryMkt is used to check if a tick is from the primary market. 								// Does NOT mean we subscribe ONLY to primary market data!								final IParentOrderEvent evt = new ParentEventWrapper(order, OmsAction.NEW_ORDER_RCVD, 0);								m_eo.onParentOrderEvent(evt);								response = null;								// In the 3.X API, onParentOrderEvent() is async, so we cannot automatically Ack just because an Exception was not thrown --Olu E. 2014-05-09								//response.setOrderAction(OmsAction.ACKNOWLEDGE_ORDER); // Successful callback i.e. no Exception, means acknowledge order							} catch (Exception e) {								response.setOrderAction(OmsAction.REJECT_ORDER); // OFR did not accept the order								if (SH.is(e.getMessage()))									response.setText("algo message: " + e.getMessage());								else									response.setText("Unknown exception from algo: " + e.getClass().getSimpleName());								m_logger.error(msgPrefix + String.format("error with ofr adapter [%s]", getMessage(e)), e);							}						}					}				} else {					response.setOrderAction(OmsAction.REJECT_ORDER);					response.setText(String.format("Cusip [%s] supplied for ticker [%s] is WRONG! We think it should be [%s]. Order REJECTED!", order.getSecurityID(),					toSymbol(order), sec.getCusip()));					m_logger.warn(msgPrefix + response.getText() + " : " + order);				}				storeAndForwardToOMS(response);				break;			case NEW_CHILD_ORDER:// A new child order has been created in the OMS				m_logger.info(msgPrefix + "Request ID: " + order.getRequestId() + " was created as slice ID : " + order.getId());				final OmsSliceId omsID = new OmsSliceId(order.getId());				m_ofrSliceMetadataMap.mapOfrIdToOmsId(omsID, new OfrSliceId(order.getRequestId())); // Store the requestID to OMS ID mapping for secondary requests				final ParentOrderMetaData po = getParentOrderMetaData(omsID);				po.onNewSlice(omsID, order);				break;			case CHILD_REJECTED:// The OMS rejected the creation of the new child order				doChildOrderUpdate(order, new ExecutionReport(order, action));				break;			default:				m_logger.info(msgPrefix + String.format("onNewOrder(): Symbol=[%s]. Unhandled action [%s]", order.getSymbol(), action.name()));				break;		}	}	private void createOrderMessage(Order order, OmsAction action) {		switch (order.getSliceType()) {			case CLIENT_ORDER:				createParentOrderMessage(order);				if (action.equals(OmsAction.NEW_ORDER_RCVD))					addNewParentOrderEntry(order);				break;			case INTERNAL_SLICE:				createChildOrderMessage(order);				break;			case SLICE:				createChildOrderMessage(order);				if (action.equals(OmsAction.NEW_CHILD_ORDER)) {					addLeavesToParent(order);				}		}	}	private void addNewParentOrderEntry(Order order) {		Mutable.Int zro = new Mutable.Int(0);		String oId = order.getId();		parentLeaves.put(oId, zro);		createParentLeavesMessage(oId, zro);	}	private String getCurrentStatus(int status) {		if ((status & 1024) == 1024)			return "Pending Ack";		if ((status & 512) == 512)			return "Rejected";		if ((status & 256) == 256)			return "Acked";		if ((status & 128) == 128)			return "Replaced";		if ((status & 64) == 64)			return "Partial";		if ((status & 32) == 32)			return "Canceled";		if ((status & 16) == 16)			return "Filled";		if ((status & 8) == 8)			return "Pending Rpl";		if ((status & 4) == 4)			return "Pending Cxl";		return null;	}	private String toSymbol(Order order) {		//return order.getSymbol().indexOf('.') != -1 || SH.is(order.getSymbolSfx()) ? order.getSymbol() + "." + order.getSymbolSfx() : order.getSymbol();		return order.getSymbolSfx() != null && order.getSymbolSfx().trim().length() > 0 ? order.getSymbol() + "." + order.getSymbolSfx() : order.getSymbol();	}	private boolean cusipSame(String left, String right) {		if (SH.length(left) == 9)			left = left.substring(0, 8);		if (SH.length(right) == 9)			right = right.substring(0, 8);		return OH.eq(left, right);	}	@Override	public void onUpdateOrder(final OmsClientOrdersExecutions manager, final Order old, final Order nuw, final OmsAction action) {		if (nuw.getSliceType().equals(SliceType.SLICE) && action.equals(OmsAction.ATTACH_EXECUTION))			updateParentLeaves(old, nuw);		createOrderMessage(nuw, action);		final Order nuw2 = VH.clone(nuw);// avoid concurrent changes		//-------Need to allow child order updates and Parent order update to proceed in parallel----------		final String msgPrefix;		if (nuw.getSliceType() == SliceType.SLICE) {			if (m_logger.isDebugEnabled()) {				m_logger.debug(String.format("onUpdateOrder(SLICE): Action=[%s], Order(old)=[%s], Order(new)=[%s]", action.name(), old, nuw));			}			final OmsSliceId omsSliceID = new OmsSliceId(nuw2.getId());			final ParentOrderMetaData po = getParentOrderMetaData(omsSliceID);			if (nuw2.getSymbolSfx() == null || nuw2.getSymbolSfx().trim().length() == 0) {				msgPrefix = String.format("BlockID=[%s], %s: ", po.getBlockId(), nuw2.getSymbol());			} else {				msgPrefix = String.format("BlockID=[%s], %s/%s: ", po.getBlockId(), nuw2.getSymbol(), nuw2.getSymbolSfx());			}			switch (action) {				case CHILD_CANCEL_SUCCEEDED: // Cancel request succeeded in OMS					m_logger.info(msgPrefix					+ String.format("onUpdateOrder(): Received Slice notification. Action=[%s], Order(old)=[%s], Order(new)=[%s]", action.name(), old, nuw2));					po.onSliceCanceled(omsSliceID, nuw2);					doChildOrderUpdate(old, nuw2, action);					break;				case CHILD_REJECTED: // Child order was rejected from FIX destination					m_logger.info(msgPrefix					+ String.format("onUpdateOrder(): Received Slice notification. Action=[%s], Order(old)=[%s], Order(new)=[%s]", action.name(), old, nuw2));					po.onSliceRejected(omsSliceID, nuw2);					doChildOrderUpdate(old, nuw2, action);					break;				case CHILD_ORDER_ACKNOWLEDGED: // External System acked the child order				case CANCEL_CHILD_ORDER: // Cancel request received by OMS for this child order				case REPLACE_CHILD_ORDER: // Replace request received by OMS for this child order				case CHILD_CANCEL_REJECTED:				case CHILD_REPLACE_REJECTED:					m_logger.info(msgPrefix					+ String.format("onUpdateOrder(): Received Slice notification. Action=[%s], Order(old)=[%s], Order(new)=[%s]", action.name(), old, nuw2));					doChildOrderUpdate(old, nuw2, action);					break;				case CHILD_REPLACE_SUCCEEDED: // Slice was successfully replaced from FIX destination					m_logger.info(msgPrefix					+ String.format("onUpdateOrder(): Received Slice notification. Action=[%s], Order(old)=[%s], Order(new)=[%s]", action.name(), old, nuw2));					m_ofrSliceMetadataMap.mapOfrIdToOmsId(omsSliceID, new OfrSliceId(nuw2.getRequestId())); // Store the new request ID for the lookup					po.onSliceModified(omsSliceID, nuw2);					doChildOrderUpdate(old, nuw2, action);					break;				case ATTACH_EXECUTION:				case ATTACH_BUST_EXECUTION:					po.onExecution(omsSliceID, nuw2);					break;				default:					m_logger.error(msgPrefix + String.format("onUpdateOrder(): Unhandled action [%s]", action.name()));					break;			}		} else { //CLIENT_ORDER			if (nuw2.getSymbolSfx() == null || nuw2.getSymbolSfx().trim().length() == 0) {				msgPrefix = String.format("BlockID=[%s], %s: ", nuw2.getId(), nuw2.getSymbol());			} else {				msgPrefix = String.format("BlockID=[%s], %s/%s: ", nuw2.getId(), nuw2.getSymbol(), nuw2.getSymbolSfx());			}			if (m_logger.isDebugEnabled()) {				m_logger.debug(msgPrefix + String.format("onUpdateOrder(%s): Action=[%s], Order(old)=[%s], Order(new)=[%s]", nuw.getSliceType(), action.name(), old, nuw));			}			switch (action) {				case ALL_CHILDREN_CANCELLED:				case CANCEL_ORDER:// Cancel request was received by the OMS for this block				case REPLACE_ORDER:// Replace request was received by the OMS for this block					m_logger.info(msgPrefix + String.format("onUpdateOrder(): Received ParentOrder. Action=[%s], Order(old)=[%s], Order(new)=[%s]", action.name(), old, nuw));					doParentOrderUpdate(nuw2, action);					break;				case ATTACH_EXECUTION:				case ATTACH_BUST_EXECUTION:					if (m_logger.isDebugEnabled())						m_logger.debug(msgPrefix + String.format("onUpdateOrder(%s): Action=[%s], getTotalExecQty=[%s]", nuw.getSliceType(), action.name(), nuw2.getTotalExecQty()));					m_cpImage.getBlockOrder(nuw2.getId()).updateSharesExecd(nuw2);					break;				case ORDER_ACKED:					m_cpImage.getBlockOrder(nuw2.getId()).initToIdleIfNecessary();					break;				case REJECT_ORDER:					m_cpImage.getBlockOrder(nuw2.getId()).update(CPStatus.Rejected);					break;				case ORDER_CANCELLED:					m_cpImage.getBlockOrder(nuw2.getId()).update(CPStatus.Canceled);					break;				case ORDER_REPLACED:					m_cpImage.getBlockOrder(nuw2.getId()).update(nuw2);					break;				//            case DONE_FOR_DAY:				//                m_cpImage.getBlockOrder(nuw2.getId()).update(CPStatus.DoneForDay);				//break;				default:					m_logger.error(msgPrefix + String.format("onUpdateOrder(): Unhandled action [%s]", action.name()));					break;			}		}	}	private void updateParentLeaves(Order old, Order nuw) {		String oId = nuw.getOrderGroupId();		Mutable.Int leaves = parentLeaves.get(oId);		int leavesRemoved = nuw.getTotalExecQty() - old.getTotalExecQty();		leaves.value -= leavesRemoved;		createParentLeavesMessage(oId, leaves);	}	private ParentOrderMetaData getParentOrderMetaData(final OmsSliceId omsID) {		return m_cachedParentOrders.get(m_ofrSliceMetadataMap.getBlockId(omsID));	}	private ParentOrderMetaData getParentOrderMetaData(final String blockID) {		return m_cachedParentOrders.get(blockID);	}	/**	 * 	 * Called from onUpdateOrder() when it is time to do the actual update	 * 	 * 	 * 	 * @param nuw	 * 	 * @param action	 */	private void doParentOrderUpdate(final Order nuw, final OmsAction action) {		final String msgPrefix;		if (nuw.getSymbolSfx() == null || nuw.getSymbolSfx().trim().length() == 0) {			msgPrefix = String.format("BlockID=[%s], %s: ", nuw.getId(), nuw.getSymbol());		} else {			msgPrefix = String.format("BlockID=[%s], %s/%s: ", nuw.getId(), nuw.getSymbol(), nuw.getSymbolSfx());		}		//		switch (action) {			case ALL_CHILDREN_CANCELLED:				handleAllChildrenCancelledNotification(msgPrefix, nuw, action);				break;			case CANCEL_ORDER:// Cancel request was received by the OMS for this order				final BlockOrder bo = m_cpImage.getBlockOrder(nuw.getId());				if (bo.isTerminal()) {					m_logger.error(msgPrefix + String.format("onParentOrderUpdate(): Attempting to CANCEL order that is already [%s]", bo.getCPStatus()));				} else					try {						final ParentOrderMetaData poMeta = getOrCreatePOMetaData(nuw.getId());						poMeta.setOMSState(OmsAction.CANCEL_ORDER);						bo.update(CPStatus.PendingCancel);						poMeta.scheduleCancelTimeout(CXLORDER_TIMEOUT_SECS); //If OFR does not respond in a timely manner, we will respond on it's behalf!						final IParentOrderEvent evt = new ParentEventWrapper(nuw, OmsAction.CANCEL_ORDER, getPriorFilled(nuw));						m_eo.onParentOrderEvent(evt);					} catch (Exception e) {						m_logger.error(msgPrefix + "error with cancel order", e);						final OmsClientAction response = oa.nw();						response.setRootOrderID(nuw.getId());						response.setOrderID(nuw.getId());						response.setOrderAction(OmsAction.REPLACE_REJECTED); //3forge does not have CANCEL_REJECTED!!						bo.resetStatus();						if (SH.is(e.getMessage()))							response.setText("algo message: " + e.getMessage());						else							response.setText("unknown exception from algo: " + e.getClass().getSimpleName());						storeAndForwardToOMS(response);					}				break;			case REPLACE_ORDER:// Replace request was received by the OMS for this order				try {					m_eo.onParentOrderEvent(new ParentEventWrapper(nuw, OmsAction.REPLACE_ORDER, getPriorFilled(nuw)));				} catch (Exception e) {					m_logger.error(msgPrefix + "error with replace order", e);					final OmsClientAction response = oa.nw();					response.setRootOrderID(nuw.getId());					response.setOrderID(nuw.getId());					response.setOrderAction(OmsAction.REPLACE_REJECTED);					if (SH.is(e.getMessage()))						response.setText("algo message: " + e.getMessage());					else						response.setText("unknown exception from algo: " + e.getClass().getSimpleName());					storeAndForwardToOMS(response);				}				break;			default:				m_logger.warn(msgPrefix + String.format("onParentOrderUpdate(): Unhandled action [%s]", action.name()));				break;		}	}	private void handleAllChildrenCancelledNotification(final String msgPrefix, final Order nuw, final OmsAction action) {		if (getOrCreatePOMetaData(nuw.getId()).isPendingCancel())			return; //This means the CANCEL_ALL_CHILDREN transaction was initiated by OfrAdapter!!		m_priorFilledQuantity.put(nuw.getId(), nuw.getTotalExecQty());		final OmsClientAction response = oa.nw();		response.setRootOrderID(nuw.getId());		response.setOrderID(nuw.getId());		try {			final Security sec = omsProxy.getRefData(toSymbol(nuw));			if (sec == null) { // Unknown Security according to central Security Master				response.setOrderAction(OmsAction.ORDER_CANCELLED); //Unsolicited Cxl back to Buyside!				response.setText("Invalid Symbol " + toSymbol(nuw));				m_logger.warn(msgPrefix + response.getText() + ", problem with order: " + nuw);			} else {				if (nuw.getIDType() == 1 && cusipSame(nuw.getSecurityID(), sec.getCusip())) { // if NOT the order has a cusip and the cusip is valid					final Rec rec = m_secMaster.findStockRecByCusip(sec.getCusip());					final PrimaryMarket primaryMkt = rec == null ? null : rec.getPrimaryMkt();					if (primaryMkt == null) {						response.setOrderAction(OmsAction.REJECT_ORDER);						response.setText(String.format("Cannot determine PRIMARY market for this order ==>[%s]<==. CUSIP=[%s]. Order Rejected", nuw, sec.getCusip()));						m_logger.error(msgPrefix + response.getText());					} else {						if (m_mktDataMgr != null)							m_mktDataMgr.subscribe(sec.getSymbol(), sec.getRic(), primaryMkt); // primaryMkt is used to check if a tick is from the primary market. 						// Does NOT mean we subscribe ONLY to primary market data!						final IParentOrderEvent evt = new ParentEventWrapper(nuw, OmsAction.NEW_ORDER_RCVD, getPriorFilled(nuw));						m_eo.onParentOrderEvent(evt); // Will Block or throw Exception						response.setOrderAction(null); //Nothing to send back to OMS						//m_cpImage.getBlockOrder(nuw.getId()).update(CPStatus.Idle);						m_cpImage.getBlockOrder(nuw.getId()).initToIdleIfNecessary();					}				} else {					response.setOrderAction(OmsAction.REJECT_ORDER);					response.setText("Cusip does not match symbol: " + sec.getCusip() + " != " + nuw.getSecurityID());					m_logger.warn(msgPrefix + response.getText() + ", problem with order: " + nuw);				}			}		} catch (Exception e) {			m_logger.error(msgPrefix + "error with cancelling all child orders", e);			response.setOrderAction(OmsAction.ORDER_CANCELLED); // OFR did not accept the order. Unsolicited Cxl back to Buyside!			if (SH.is(e.getMessage()))				response.setText("algo message: " + e.getMessage());			else				response.setText("unknown exception from algo: " + e.getClass().getSimpleName());			m_logger.error(msgPrefix + "error with ofr adapter", e);		}		if (response.getOrderAction() != null)			storeAndForwardToOMS(response);	}	private void doChildOrderUpdate(final Order old, final Order nuw, final OmsAction action) {		final String msgPrefix;		if (nuw.getSymbolSfx() == null || nuw.getSymbolSfx().trim().length() == 0) {			msgPrefix = String.format("Block [%s]: ChildOrder=[%s], %s: ", nuw.getOrderGroupId(), nuw.getId(), nuw.getSymbol());		} else {			msgPrefix = String.format("Block [%s]: ChildOrder=[%s], %s/%s: ", nuw.getOrderGroupId(), nuw.getId(), nuw.getSymbol(), nuw.getSymbolSfx());		}		m_logger.info(msgPrefix + String.format("Received ChildOrder Update. Action=[%s]", action.name()));		if (nuw.getSliceType() != SliceType.SLICE) { // Only pass on events on the slice. OFR is not interested in the exchange leaves update on the			throw new RuntimeException(msgPrefix + "Logic error. Received Block notification in doChildOrderUpdate()");		}		try {			switch (action) {				case REPLACE_CHILD_ORDER: // Replace request received by OMS for this child order					if (m_logger.isDebugEnabled())						m_logger.debug(msgPrefix								+ String.format(										"doChildOrderUpdate(): Dropping PdgReplace a.k.a REPLACE_CHILD_ORDER because it is buggy and OFR can live without it! Old slice image=[%s], New Slice image=[%s]",										old, nuw));					break;				case CHILD_ORDER_ACKNOWLEDGED: // External System acked the child order				case CANCEL_CHILD_ORDER: // Cancel request received by OMS for this child order				case CHILD_CANCEL_SUCCEEDED: // Cancel request succeeded in OMS				case CHILD_REJECTED: // Child order was rejected from FIX destination				case CHILD_REPLACE_SUCCEEDED: // Slice was successfully replaced from FIX destination					doChildOrderUpdate(nuw, new ExecutionReport(nuw, action));					break;				case CHILD_CANCEL_REJECTED:				case CHILD_REPLACE_REJECTED:					/* Need to fixup tag 11 and 41 because 3forge API doesnt do it! */					final CancelRejectWrapper.Builder bldr = new CancelRejectWrapper.Builder();					bldr.origClOrdID = nuw.getRequestId();					bldr.clOrdID = m_ofrSliceMetadataMap.getClOrdIdStr(new OfrSliceId(nuw.getRequestId()));					if (bldr.clOrdID == null)						bldr.clOrdID = bldr.origClOrdID;					bldr.cxlRejReason = "9";					bldr.text = nuw.getText();					final CancelRejectWrapper msg = new CancelRejectWrapper(nuw, bldr);					m_eo.onCancelRejected(msg);					break;				default:					m_logger.error(msgPrefix + String.format("Unhandled action [%s] for child order [%s]", action.name(), nuw));			}		} catch (Exception e) {			m_logger.error(msgPrefix + String.format("doChildOrderUpdate(): %s", e.getMessage()), e);		}	}	private void doChildOrderUpdate(final Order o, final ExecutionReport execRpt) {		final String msgPrefix = String.format("ChildOrder=[%s], %s: ", o.getId(), o.getSymbol());		m_logger.info(msgPrefix + String.format("Received ExecRpt: ExecType=[%s], ExecRpt=[%s]", execRpt.getExecType(), execRpt));		try {			m_eo.onExecutionReport(execRpt);		} catch (Exception e) {			m_logger.error(msgPrefix + String.format("doChildOrderUpdate(Ack): %s", e.getMessage()), e);		}	}	private int getPriorFilled(Order nuw) {		return CH.getOr(m_priorFilledQuantity, nuw.getId(), 0);	}	@Override	public void onNewExecution(final OmsClientOrdersExecutions manager, final Execution exec, final OmsAction action) {		createExecutionMessage(exec);		final Order o = manager.getOrder(exec.getSourceSystem(), exec.getOrderId()); // Get the order associated with this Execution		if (o != null && o.getSliceType() == SliceType.SLICE) { // Only report child executions. Parent executions are not interesting for the OFR			final ExecutionReport rpt = new ExecutionReport(o, exec, action);			doChildOrderUpdate(o, rpt);		}	}	@Override	public void onConnected(OmsClientOrdersExecutionsManager manager) {		m_logger.info("*****************OFR CONNECTED to OMS**************");	}	@Override	public void onDisconnected(OmsClientOrdersExecutionsManager manager) {		// TODO: Commit Suicide. If the OMS goes down a new OFR should be instantiated.		m_logger.error("*****************OFR DISCONNECTED from OMS!!**************");	}	private static void setExecInstrs(final ChildOrderRequest child, final AlgoPrice price) {		if (child.getOrderType() == OrderType.PEGGED) {			if (price.getPegType() == AlgoPrice.PegType.MIDPOINT_PEG) {				child.setExecInstructions(ExecInstruction.addExecInstruction(null, ExecInstruction.MIDPOINT_PEGGED));			} else if (child.getSide() == Side.BUY || child.getSide() == Side.BUY_MINUS) {				switch (price.getPegType()) {					case PEG_TO_BID:						child.setExecInstructions(ExecInstruction.addExecInstruction(null, ExecInstruction.PRIMARY_PEG));						break;					case PEG_TO_ASK:						child.setExecInstructions(ExecInstruction.addExecInstruction(null, ExecInstruction.MARKET_PEG));						break;				}			} else {				switch (price.getPegType()) {					case PEG_TO_ASK:						child.setExecInstructions(ExecInstruction.addExecInstruction(null, ExecInstruction.PRIMARY_PEG));						break;					case PEG_TO_BID:						child.setExecInstructions(ExecInstruction.addExecInstruction(null, ExecInstruction.MARKET_PEG));						break;				}			}		}	}	// IEmsServices	@Override	public String sendNewChildOrder(INewOrderRequestMsg req) {		final OmsClientAction action = oa.nw(); // Create the message to send		action.setOrderAction(OmsAction.NEW_CHILD_ORDER); // Request a new child order.The type is used for routing this message		action.setRootOrderID(req.getBlockID()); // Set the root order ID for the OMS		//		final ChildNewOrderRequest child = cr.nw(); // Create the details of this request		action.setChildRequest(child); // Attach the details object to the message to send		action.setOrderID(req.getBlockID()); // ID of parent that needs to create the child		child.setSessionName(req.getBroker()); // Downstream session associated with this child order		child.setDestination(PrimaryMarket.isNASDAQ(req.getVenue()) ? "INET" : req.getVenue()); // Downstream tag 100		child.setOrderQty(req.getOrderQty());		child.setOrderType(OFRAdapterUtil.to3ForgeOrderType(req.getAlgoPrice()));		child.setSide(OFRAdapterUtil.to3ForgeSide(req.getSide()));		setExecInstrs(child, req.getAlgoPrice());		//		if (child.getOrderType() != OrderType.MARKET) {			child.setLimitPx(req.getAlgoPrice().getLimitPrice());		}		child.setSide(OFRAdapterUtil.to3ForgeSide(req.getSide()));		child.setTimeInForce(OFRAdapterUtil.to3ForgeTIF(req.getTimeInForce()));		final String tag11 = getContainer().getServices().getTicketGenerator("OFROrderState").createNextId(); // Create a new id for this request. aka Tag11		child.setRequestId(tag11); // Set the request ID for this message		m_logger.info(String.format("sendNewChildOrder(): BlockID=[%s]: Now forwarding NEW SLICE CREATE request to OMS. slice ID=[%s]", req.getBlockID(), tag11));		//		m_ofrSliceMetadataMap.add(new SliceMetadata(new OfrSliceId(tag11), req.getBlockID()));		toOmsRequestPort.request(action, null); // Send the command to the OMS		return tag11; // Inform the OFR of the request ID	}	@Override	public void cancelChildOrder(final String blockID, final String childID) throws OrderModifyException {		final OmsSliceId omsID = m_ofrSliceMetadataMap.getOmsIdFor(new OfrSliceId(childID));		if (omsID == null) {			throw new OrderModifyException("Unknown child order " + childID + " for block " + blockID + ". Order may not be acked yet?");		}		final OmsClientAction action = oa.nw();		action.setOrderAction(OmsAction.CANCEL_CHILD_ORDER);		action.setOrderID(omsID.toString());		action.setRootOrderID(blockID);		toOmsRequestPort.request(action, null);	}	@Override	public String amendChildOrder(final AmendOrderRequestMsg amend) throws OrderModifyException {		final OmsClientAction action = oa.nw();		action.setOrderAction(OmsAction.REPLACE_CHILD_ORDER);		final OmsSliceId omsID = m_ofrSliceMetadataMap.getOmsIdFor(new OfrSliceId(amend.getOrigClOrdID()));		if (omsID == null) {			throw new OrderModifyException(String.format("amendChildOrder(): Unknown child order tag 41=%s for block %s. Order may not be acked yet?", amend.getOrigClOrdID(),			amend.getBlockID()));		}		action.setRootOrderID(amend.getBlockID());		action.setOrderID(omsID.toString());		final AlgoPrice price = amend.getNewPrice();		final ChildOrderRequest child = ar.nw();		child.setSide(OFRAdapterUtil.to3ForgeSide(amend.getSide()));		child.setOrderType(OFRAdapterUtil.to3ForgeOrderType(price));		setExecInstrs(child, price);		if (child.getOrderType() != OrderType.MARKET) {			child.setLimitPx(price.getLimitPrice());		}		child.setOrderQty(amend.getNewQty());		final String tag41 = amend.getOrigClOrdID();		final String tag11 = getContainer().getServices().getTicketGenerator("OFROrderState").createNextId();		child.setOrigRequestId(tag41);		child.setRequestId(tag11);		m_ofrSliceMetadataMap.storeCxlRplInfo(amend.getBlockID(), child);		action.setChildRequest(child);		m_logger.info(String.format("amendChildOrder(): BlockID=[%s]: Attempting to REPLACE [%s] with [%s]", amend.getBlockID(), tag41, tag11));		//		toOmsRequestPort.request(action, null);		return child.getRequestId();	}	@Override	public void onParentOrderStatusUpdate(final IParentOrderStatusUpdateMsg msg) {		if (m_logger.isDebugEnabled()) {			m_logger.debug(String.format(" *********** onParentOrderStatusUpdate(): BEGIN: BlockID=[%s]: updateType=[%s], msg==>[%s]", msg.getBlockID(), msg.getUpdateType(), msg));		}		//		final OmsClientAction action = oa.nw();		final String blockID = msg.getBlockID();		action.setRootOrderID(blockID);		action.setOrderID(blockID);		//1st notify OMS about Cancels and Modifies 		final UpdateType updType = msg.getUpdateType();		if (updType == UpdateType.Canceled) {			final ParentOrderMetaData po = getParentOrderMetaData(blockID);			if (po == null) {				m_logger.error(String.format("Cannot locate ParentOrder for blockID [%s]", blockID));			} else { //do deferred cancel notification. wait until leavesQty==0				po.cancelCxlTimeoutTask(); //because we have heard back from OFR				po.doDefferedOMSOrderCxldNotification(action);			}		} else if (updType == UpdateType.Accepted) {			action.setOrderAction(OmsAction.ACKNOWLEDGE_ORDER);			storeAndForwardToOMS(action);		} else if (updType == UpdateType.Rejected) {			action.setOrderAction(OmsAction.REJECT_ORDER);			action.setText(String.format("Invalid order [%s]. Order Rejected", action.getRootOrderID()));			storeAndForwardToOMS(action);		} else if (updType == UpdateType.Modified) {			action.setOrderAction(OmsAction.ORDER_REPLACED);			storeAndForwardToOMS(action);		} else if (updType == UpdateType.DoneForDay) {			action.setOrderAction(OmsAction.DONE_FOR_DAY);			action.setText(String.format("Order [%s] is Done for the Day", action.getRootOrderID()));			storeAndForwardToOMS(action);		} else { //Control panel notification			m_cpImage.getBlockOrder(msg.getBlockID()).update(msg);		}		if (m_logger.isDebugEnabled()) {			m_logger.debug(String.format(" *********** onParentOrderStatusUpdate(): END: BlockID=[%s]: updateType=[%s], msg==>[%s]", msg.getBlockID(), msg.getUpdateType(), msg));		}	}	@Override	public void storeBinStatistics(List<IBinStatistics> paramList) {		// IGNORE	}	@Override	public List<IBinStatistics> getBinStatistics(QueryKey paramQueryKey) {		return null;		// IGNORE FOR NOW	}	@Override	public void onControlPanelAlert(final AlertMsg alert) {		if (m_logger.isDebugEnabled())			m_logger.debug(String.format("Received AlertMsg==>[%s]", alert));		final CPAlertMsg.Builder bldr = CPAlertMsg.newBuilder();		bldr.setText(alert.getMsg());		if (alert.getBlockID() != null)			bldr.setBlockId(alert.getBlockID());		if (alert.getAlertLevel() != null) {			if (alert.isInfo())				bldr.setLevel(CPAlertLevel.INFO);			else if (alert.isWarning())				bldr.setLevel(CPAlertLevel.WARN);			else if (alert.isError())				bldr.setLevel(CPAlertLevel.ERROR);			else				bldr.setLevel(CPAlertLevel.FATAL);		}		final SJLSTime alertTime = ProtobufUtils.toSJLSTime(alert.getTimeStamp());		bldr.setTimeStamp(alertTime);		final CPAlertMsg msg = bldr.build();		m_cpServer.publish(msg);		//		// Store the alert if it is block-specific or is an error or higher		if (msg.getBlockId() != null && msg.getBlockId().length() > 0 && (msg.getLevel() == CPAlertLevel.ERROR || msg.getLevel() == CPAlertLevel.FATAL)) {			final BlockOrder bo = m_cpImage.getBlockOrder(msg.getBlockId());			bo.storeErrorAlertMsg(msg); //store for snapshots!		}	}	@Override	public void onStarted(OmsClientOrdersExecutionsManager manager) {		// manager.requestSnapshot();	}	/**	 * 	 * This should also be queued but we can get away with not queuing it for now	 */	@Override	public void onRcvBroadcast(final OmsClientOrdersExecutionsManager manager, final MapMessage clientBroadcast) {		// check for OLD-STYLE OFR commands		m_logger.error("onRcvBroadcast(): broadcast msg ==>[" + clientBroadcast + "]");	}	@Override	public void onLogin() {		m_logger.info("onLogin()");	}	@Override	public void onLoginFailure() {		m_logger.error("onLoginFailure()");	}	@Override	public void onDisconnect(final String reason, final boolean propagateToOfr) {		m_logger.error(String.format("onDisconnect(%s)", reason));		if (propagateToOfr) {			m_eo.onMarketDataDisconnect(reason);		}	}	public void setOmsProxy(OMSConnectionHandler omsProxy) {		this.omsProxy = omsProxy;	}	public IExecutionOptimizer getEO() {		return m_eo;	}	@Override	public void onMarketData(final ITickData[] pair) {		if (pair == null)			return;		for (ITickData tick : pair) {			if (tick == null)				continue;			try {				if (tick instanceof IQuoteData) {					m_eo.onQuote((IQuoteData) tick);				} else if (tick instanceof ITradeData) {					final ITradeData trade = (ITradeData) tick;					if (trade.isOpeningTrade()) {						if (trade.isFromPrimaryMkt()) {							m_logger.info("***Received OPENING Trade from PRIMARY Market*** ==>" + trade + "<==");						} else {							m_logger.info("***Received a trade with OPENING status from a NON-PRIMARY Market*** ==>" + trade + "<==");						}					}					m_eo.onTrade(trade);				}			} catch (Exception e) {				m_logger.error(e.getMessage(), e);			}		}	}	@Override	public void onSubscriptionFailure() {		m_logger.error("onSubscriptionFailure()");	}	private void storeAndForwardToOMS(final OmsClientAction clientAction) {		if (clientAction != null) {			getOrCreatePOMetaData(clientAction.getRootOrderID()).setOMSState(clientAction.getOrderAction()).sendToOMS(clientAction);		}	}	/**	 * 	 * get (or create one if it does not exist) a ParentOrder metadata entry. Never returns null	 * 	 * 	 * 	 * @param blockID	 * 	 * @return	 */	private synchronized ParentOrderMetaData getOrCreatePOMetaData(final String blockID) {		ParentOrderMetaData poMeta = m_cachedParentOrders.get(blockID);		if (poMeta == null) {			poMeta = new ParentOrderMetaData(this, blockID);			m_cachedParentOrders.put(blockID, poMeta);		}		return poMeta;	}	private final static String getMessage(final Exception e) {		return (e == null || e.getMessage() == null) ? "NullPointer" : e.getMessage();	}	public OfrSliceId getOfrIdFor(final OmsSliceId omsSliceId) {		return m_ofrSliceMetadataMap.getOfrIdFor(omsSliceId);	}	public static void setRouteToBrokerTag(final int tag) {		m_routeToBrokerTag = tag;	}	public static int getRouteToBrokerTag() {		return m_routeToBrokerTag;	}	public static void setRouteToBrokerIgnoreValue(final String v) {		if (v != null && v.trim().length() > 0)			m_routeToBrokerIgnoreValue = v.trim();	}	public static String getRouteToBrokerIgnoreValue() {		return m_routeToBrokerIgnoreValue;	}	public ObjectGeneratorForClass<OmsClientAction> getOmsClientActionGenerator() {		return oa;	}	public Timer getTimer() {		return m_timer;	}	/**	 * 	 * Callback for the receipt of a Protobuf Msg from CP	 */	@Override	public void onMessage(final Message msg, final ICPInstance cpInstance) {		if (m_logger.isDebugEnabled()) {			m_logger.debug(String.format("Recvd msg [%s] from CP...", msg));		}		//		try {			if (msg instanceof CPCommandMsg) {				handleMsg((CPCommandMsg) msg);			} else if (msg instanceof SaveAllocationCmdMsg) {				handleMsg((SaveAllocationCmdMsg) msg, cpInstance);			} else {				throw new EOException(String.format("Unknown message ==>[%s]<==", msg));			}		} catch (Exception e) {			m_logger.error(getMessage(e), e);		}	}	private void handleMsg(final CPCommandMsg msg) throws EOException {		final String blockID = msg.getBlockId();		final String CPid = String.format("ControlPanelID=[%s:%s] ", msg.getHostname(), msg.getUserId());		m_logger.info(CPid + String.format("Handling CP command: [%s]", msg));		if (msg.getCmdType() == CPCommandMsg.CmdType.RESUME || msg.getCmdType() == CPCommandMsg.CmdType.PAUSE) {			final StrategyUpdateMsg stgyUpdate = new StrategyUpdateMsg(blockID);			stgyUpdate.setUpdateType(IStrategyUpdateMsg.UpdateType.AUTOTRADE);			stgyUpdate.setAutotrade(msg.getCmdType() == CPCommandMsg.CmdType.RESUME);			m_eo.updateOrderStrategy(stgyUpdate);		} else if (msg.getCmdType() == CPCommandMsg.CmdType.CANCEL) {			final BlockOrder bo = m_cpImage.getBlockOrder(blockID);			if (bo.isTerminal()) {				m_logger.warn(CPid + String.format("Ignoring CANCEL request for block [%s] because it is already [%s]", blockID, bo.getCPStatus()));			} else {				final ParentOrderMetaData poMeta = getOrCreatePOMetaData(blockID);				poMeta.setOMSState(OmsAction.CANCEL_ORDER);				poMeta.scheduleCancelTimeout(CXLORDER_TIMEOUT_SECS); //If OFR does not respond in a timely manner, we will respond on it's behalf!                        				m_eo.onParentOrderEvent(new ParentCancelCommandWrapper(blockID));			}		} else if (msg.getCmdType() == CPCommandMsg.CmdType.STOP_TRADING) {			for (final BlockOrder bo : m_cpImage.getAllBlocks()) {				if (!bo.isTerminal()) {					try {						final ParentOrderMetaData poMeta = getOrCreatePOMetaData(bo.getBlockId());						poMeta.setOMSState(OmsAction.CANCEL_ORDER);						poMeta.scheduleCancelTimeout(CXLORDER_TIMEOUT_SECS); //If OFR does not respond in a timely manner, we will respond on it's behalf!                        						m_eo.onParentOrderEvent(new ParentCancelCommandWrapper(bo.getBlockId()));					} catch (Exception e) {						m_logger.error(CPid + String.format(" %s", e.getMessage()), e);					}				}			}		} else if (msg.getCmdType() == CPCommandMsg.CmdType.ALGO_PARAMS) {			if (msg.hasAlgoParams()) {				final CPAlgoParams p = msg.getAlgoParams();				final AlgoParamsIS is = new AlgoParamsIS(); //because IS is the only strategy we support				if (p.hasStartTime())					is.setStartTime(ProtobufUtils.toDateTime(p.getStartTime()));				if (p.hasEndTime())					is.setEndTime(ProtobufUtils.toDateTime(p.getEndTime()));				if (p.hasLowerPr())					is.setLowerPct(p.getLowerPr());				if (p.hasUpperPr())					is.setUpperPct(p.getUpperPr());				if (p.hasIsHardUpperPr())					is.setHardUpperPRIndicator(p.getIsHardUpperPr());				if (p.hasParticipateOnOpen())					is.setParticipateOnOpen(p.getParticipateOnOpen());				if (p.hasParticipateOnClose())					is.setParticipateOnClose(p.getParticipateOnClose());				if (p.hasOnOpenAmount())					is.setOnOpenAmt(ProtobufUtils.toAmount(p.getOnOpenAmount()));				if (p.hasMaxDeviation())					is.setMaxdeviationFromProfile(p.getMaxDeviation());				if (p.hasRiskTolerance())					is.setRiskTolerance(p.getRiskTolerance());				if (p.hasLimitPrice())					is.setLimitPrice(new LimitPrice(p.getLimitPrice())); //NOTE: zero price is Market order!!				if (p.hasIsPaused())					is.setIsPaused(p.getIsPaused());				m_eo.updateOrderStrategy(blockID, is);			} else {				throw new EOException(CPid + "Bad AlgoParams Update command. AlgoParams not specified!");			}		} else {			throw new EOException("Unknown message!");		}	}	private void handleMsg(final SaveAllocationCmdMsg msg, final ICPInstance cpInstance) {		final String hostName = msg.getHostname();		final String userID = msg.getUserId();		final String CPid = String.format("ControlPanelID=[%s:%s] ", hostName, userID);		m_logger.info(CPid + String.format("Handling CP command: [%s]", msg));		final CmdResponseMsg.Builder bldr = CmdResponseMsg.newBuilder().setHostname(hostName).setUserId(userID);		try {			m_brokerAllocMgr.save(msg.getAllocationRecList());			cpInstance.write(bldr.setLevel(CPAlertLevel.INFO).setText("Broker allocations successfully saved").build());		} catch (Exception e) {			final String errMsg = getMessage(e);			m_logger.error(errMsg, e);			cpInstance.write(bldr.setLevel(CPAlertLevel.ERROR).setText(errMsg).build());		}		//TODO: Need to rebroadcast	}	private AmiClient amiClient;	private static final String CANCEL = "cancel";	@Override	public void onCommand(AmiClient source, String requestId, String cmd, String userName, String objectType, String objectId, Map<String, Object> params) {		System.out.println("command received: " + cmd);		if (CANCEL.equals(cmd)) {			List<Map> rows = (List<Map>) params.get("V");			for (Map row : rows) {				String orderId = (String) row.get("oI");				System.out.println("CANCEL " + orderId);				// TODO: Insert code here for handling cancel requests from use.  			}			String value = "Canceled your orders!";//this can be null if you don't want a message displayed to user;			amiClient.startResponseMessage(requestId).addMessageParamInt("S", 1).addMessageParamString("M", value);			amiClient.sendMessageAndFlush();		}	}	@Override	public void onLoggedIn(AmiClient rawAmiClient) {		amiClient.sendCommandDefinition(new AmiClientCommandDef(CANCEL).setFields("oI").setSelectMode(1, null));	}	@Override	public void onTransactionComplete(OmsClientNotification action) {		if (!amiClient.isConnected())			return;		amiClient.flush();	}	private void initAmiClient() {		this.amiClient = new AmiClient();		amiClient.addListener(this);		int port = getTools().getOptional("ofr.ami.port", AmiClient.DEFAULT_PORT);		String host = getTools().getOptional("ofr.ami.host", AmiClient.DEFAULT_HOST);		String loginId = getTools().getOptional("ofr.ami.loginId", "OFR");		amiClient.start("flux.3forge.net", 3290, loginId, 0);	}	private void createParentLeavesMessage(String orderId, Int leaves) {		if (!amiClient.isConnected())			return;		amiClient.startObjectMessage("pO", orderId, 0);		amiClient.addMessageParamInt("l", leaves.value);		amiClient.sendMessage();	}	private void addLeavesToParent(Order order) {		String oId = order.getOrderGroupId();		Mutable.Int leaves = parentLeaves.get(oId);		leaves.value += order.getOrderQty();		createParentLeavesMessage(oId, leaves);	}	private void createChildOrderMessage(Order order) {		if (!amiClient.isConnected())			return;		String orderId = order.getId();		amiClient.startObjectMessage("cO", orderId, 0);		addOrderParamsToMessage(order);	}	private void createParentOrderMessage(Order order) {		if (!amiClient.isConnected())			return;		String orderId = order.getId();		amiClient.startObjectMessage("pO", orderId, 0);		addOrderParamsToMessage(order);	}	private void addOrderParamsToMessage(Order order) {		String currentStatus = getCurrentStatus(order.getOrderStatus());		String orderId = order.getId();		String account = order.getAccount();		String symbol = order.getSymbol();		int orderQty = order.getOrderQty();		Double limitPx = order.getLimitPx();		Side side = order.getSide();		String symbolSuffix = order.getSymbolSfx();		DateNanos createdTime = order.getCreatedTime();		String currency = order.getCurrency();		String destination = order.getDestination();		String execInstructions = order.getExecInstructions();		String externalOrderId = order.getExternalOrderId();		int idType = order.getIDType();		String locateBroker = order.getLocateBroker();		String locateId = order.getLocateId();		String orderCapacity = order.getOrderCapacity();		String orderGroupId = order.getOrderGroupId();		int orderStatus = order.getOrderStatus();		String origRequestId = order.getOrigRequestId();		String requestId = order.getRequestId();		int revision = order.getRevision();		String rule80A = order.getRule80A();		String securityId = order.getSecurityID();		int securityRefId = order.getSecurityRefId();		String senderSubId = order.getSenderSubId();		String sessionName = order.getSessionName();		String sourceSystem = order.getSourceSystem();		String text = order.getText();		int totalExecQuantity = order.getTotalExecQty();		double totalExexValue = order.getTotalExecValue();		DateNanos updateTime = order.getUpdatedTime();		amiClient.addMessageParamString("oI", orderId);		amiClient.addMessageParamString("a", account);		amiClient.addMessageParamString("sy", symbol);		amiClient.addMessageParamInt("oQ", orderQty);		amiClient.addMessageParamDouble("lP", limitPx);		amiClient.addMessageParamEnum("s", side.toString());		amiClient.addMessageParamString("sS", symbolSuffix);		amiClient.addMessageParamLong("cT", createdTime.getTimeMillis());		amiClient.addMessageParamString("c", currency);		amiClient.addMessageParamString("d", destination);		amiClient.addMessageParamString("eI", execInstructions);		amiClient.addMessageParamString("eO", externalOrderId);		amiClient.addMessageParamInt("iT", idType);		amiClient.addMessageParamString("lB", locateBroker);		amiClient.addMessageParamString("lI", locateId);		amiClient.addMessageParamString("oC", orderCapacity);		amiClient.addMessageParamString("oG", orderGroupId);		amiClient.addMessageParamInt("oS", orderStatus);		amiClient.addMessageParamString("oR", origRequestId);		amiClient.addMessageParamString("rI", requestId);		amiClient.addMessageParamInt("r", revision);		amiClient.addMessageParamString("rA", rule80A);		amiClient.addMessageParamString("sI", securityId);		amiClient.addMessageParamInt("sR", securityRefId);		amiClient.addMessageParamString("sSI", senderSubId);		amiClient.addMessageParamString("sN", sessionName);		amiClient.addMessageParamString("sSys", sourceSystem);		amiClient.addMessageParamString("t", text);		amiClient.addMessageParamInt("tQ", totalExecQuantity);		amiClient.addMessageParamDouble("tV", totalExexValue);		amiClient.addMessageParamLong("uT", updateTime.getTimeMillis());		amiClient.addMessageParamString("cS", currentStatus);		amiClient.sendMessage();	}	private void createExecutionMessage(Execution exec) {		if (!amiClient.isConnected())			return;		String execId = exec.getId();		amiClient.startObjectMessage("sOE", execId, 0);		String contraBroker = exec.getContraBroker();		String execBroker = exec.getExecBroker();		String execGroupId = exec.getExecGroupID();		double execPrice = exec.getExecPx();		int execQty = exec.getExecQty();		String execRefId = exec.getExecRefID();		int status = exec.getExecStatus();		DateNanos execTime = exec.getExecTime();		int execTransType = exec.getExecTransType();		boolean isLatest = exec.getIsLatest();		String lastMkt = exec.getLastMkt();		String orderId = exec.getOrderId();		int orderRevision = exec.getOrderRevision();		//		String refId = exec.getRefId();		int revision = exec.getRevision();		String sourceSystem = exec.getSourceSystem();		String text = exec.getText();		amiClient.addMessageParamString("cB", contraBroker);		amiClient.addMessageParamString("eB", execBroker);		amiClient.addMessageParamString("eG", execGroupId);		amiClient.addMessageParamDouble("eP", execPrice);		amiClient.addMessageParamInt("eQ", execQty);		amiClient.addMessageParamString("eR", execRefId);		amiClient.addMessageParamInt("s", status);		amiClient.addMessageParamLong("eT", execTime.getTimeMillis());		amiClient.addMessageParamInt("eTT", execTransType);		amiClient.addMessageParamBoolean("iL", isLatest);		amiClient.addMessageParamString("lM", lastMkt);		amiClient.addMessageParamString("oI", orderId);		amiClient.addMessageParamInt("oR", orderRevision);		amiClient.addMessageParamString("rI", exec.getExecRefID());		amiClient.addMessageParamInt("r", revision);		amiClient.addMessageParamString("sS", sourceSystem);		amiClient.addMessageParamString("t", text);		amiClient.sendMessage();	}	@Override	public void onMessageReceived(AmiClient source, long now, int seqnum, int status, CharSequence message) {	}	@Override	public void onMessageSent(AmiClient source, CharSequence message) {	}	@Override	public void onConnect(AmiClient source) {	}	@Override	public void onDisconnect(AmiClient source) {	}	@Override	public void onResponse(OmsClientOrdersExecutionsManager manager, ResultMessage<TextMessage> response) {		// TODO Auto-generated method stub	}}