package com.f1.ami.amidb.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.List;
import java.util.logging.Logger;

import com.f1.ami.amicommon.msg.AmiCenterQueryDsRequest;
import com.f1.ami.center.ds.AmiStatement;
import com.f1.base.Table;
import com.f1.utils.LH;
import com.f1.utils.OH;
import com.f1.utils.ToDoException;
import com.f1.utils.structs.Tuple2;
import com.f1.utils.structs.table.BasicTable;

public class AmiDbJdbcStatement implements AmiStatement {

	private AmiDbJdbcConnection connection;
	private boolean isClosed;
	private int maxRows = Integer.MAX_VALUE;
	private boolean poolable;
	private TableResultSet resultSet;
	private long queryTimeoutMillis = AmiCenterQueryDsRequest.USE_DEFAULT_TIMEOUT;
	private ResultSet generatedKeys;
	private static final Logger log = LH.get();
	private static final Table EMPTY_TABLE = new BasicTable();

	public AmiDbJdbcStatement(AmiDbJdbcConnection connection) {
		this.connection = connection;
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		execute(sql);
		return this.resultSet;
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		try {
			return this.connection.getAmiClient().queryExecuteUpdate(sql, getQueryTimeoutMillis());
		} catch (Exception e) {
			this.resultSet = null;
			this.generatedKeys = null;
			throw new SQLException(e.getMessage(), e);
		}
	}
	@Override
	public boolean execute(String sql) throws SQLException {
		try {
			Tuple2<List<Table>, List<Object>> tuple = this.connection.getAmiClient().query(sql, getQueryTimeoutMillis());
			this.resultSet = null;
			this.generatedKeys = null;
			if (tuple != null) {
				List<Table> t = tuple.getA();
				if (t != null)
					for (int i = t.size() - 1; i >= 0; i--)
						this.resultSet = new TableResultSet(this, t.get(i), this.resultSet);
				List<Object> gk = tuple.getB();
				if (gk != null)
					this.generatedKeys = new TableResultSet(this, toGeneratedKeyTable(gk), this.resultSet);
			}
			return this.resultSet != null;
		} catch (SQLException e) {
			this.resultSet = null;
			this.generatedKeys = null;
			throw e;
		} catch (Exception e) {
			this.resultSet = null;
			this.generatedKeys = null;
			throw new SQLException(e.getMessage(), e);
		}
	}

	private static Table toGeneratedKeyTable(List<Object> gk) {
		Class c = OH.getWidestIgnoreNull(gk);
		Table t = new BasicTable(c, "ID");
		t.setTitle("GeneratedKeys");
		for (Object o : gk)
			t.getRows().addRow(o);
		return t;

	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		return this.resultSet;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return -1;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		return executeUpdate(sql);
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		return executeUpdate(sql);
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		return executeUpdate(sql);
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		return execute(sql);
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return execute(sql);
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		return execute(sql);
	}

	@Override
	public void cancel() throws SQLException {
	}
	@Override
	public int getResultSetType() throws SQLException {
		return ResultSet.TYPE_SCROLL_INSENSITIVE;
	}
	@Override
	public boolean getMoreResults() throws SQLException {
		if (this.resultSet == null)
			return false;
		this.resultSet = this.resultSet.nextResultSet();
		return this.resultSet != null;
	}
	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return false;
	}
	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	@Override
	public void close() throws SQLException {
		isClosed = true;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return Integer.MAX_VALUE;
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		throw unsupported("setMaxFieldSize");
	}

	@Override
	public int getMaxRows() throws SQLException {
		return this.maxRows;
	}
	@Override
	public void setMaxRows(int max) throws SQLException {
		this.maxRows = max;
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		throw unsupported("setEscapeProcessing");
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		return (int) ((this.queryTimeoutMillis + 999) / 1000);
	}

	@Override
	public long getQueryTimeoutMillis() {
		return this.queryTimeoutMillis;
	}
	@Override
	public void setQueryTimeoutMillis(long millis) {
		if (millis == AmiCenterQueryDsRequest.NO_TIMEOUT || millis == 0)
			this.queryTimeoutMillis = AmiCenterQueryDsRequest.NO_TIMEOUT;
		else if (millis == AmiCenterQueryDsRequest.USE_DEFAULT_TIMEOUT)
			this.queryTimeoutMillis = AmiCenterQueryDsRequest.USE_DEFAULT_TIMEOUT;
		this.queryTimeoutMillis = millis;
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		if (seconds == AmiCenterQueryDsRequest.NO_TIMEOUT || seconds == 0)
			this.queryTimeoutMillis = AmiCenterQueryDsRequest.NO_TIMEOUT;
		else if (seconds == AmiCenterQueryDsRequest.USE_DEFAULT_TIMEOUT)
			this.queryTimeoutMillis = AmiCenterQueryDsRequest.USE_DEFAULT_TIMEOUT;
		else
			this.queryTimeoutMillis = seconds * 1000;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		throw unsupported("setCursorName");
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		if (direction != getFetchDirection())
			throw unsupported("setFetchDirection");
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return ResultSet.FETCH_FORWARD;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		throw unsupported("setFetchSize");
	}

	@Override
	public int getFetchSize() throws SQLException {
		return Integer.MAX_VALUE;
	}
	@Override
	public int getResultSetConcurrency() throws SQLException {
		return ResultSet.CONCUR_READ_ONLY;
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		throw unsupported("addBatch");
	}

	@Override
	public void clearBatch() throws SQLException {
		throw unsupported("clearBatch");

	}

	@Override
	public int[] executeBatch() throws SQLException {
		throw unsupported("executeBatch");
	}

	@Override
	public Connection getConnection() throws SQLException {
		return this.connection;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		if (this.generatedKeys == null)
			this.generatedKeys = new TableResultSet(this, EMPTY_TABLE);
		return this.generatedKeys;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return ResultSet.HOLD_CURSORS_OVER_COMMIT;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return isClosed || this.connection.isClosed();
	}
	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		this.poolable = poolable;
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return poolable;
	}

	public void closeOnCompletion() throws SQLException {
		throw new ToDoException();
	}

	public boolean isCloseOnCompletion() throws SQLException {
		throw new ToDoException();
	}
	private UnsupportedOperationException unsupported(String msg) {
		LH.info(log, getClass().getSimpleName() + ":Going to throw unsupported operation exception: " + msg);
		return new UnsupportedOperationException(msg);
	}

}
