package com.f1.ami.web;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.IOException;import java.io.PrintStream;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.Set;import java.util.logging.Logger;import com.f1.ami.amicommon.AmiStartup;import com.f1.ami.amicommon.AmiUtils;import com.f1.ami.amiscript.AmiAbstractMemberMethod;import com.f1.ami.extern.PythonExtern;import com.f1.ami.web.amiscript.AmiWebAmiScriptDerivedCellParser;import com.f1.ami.web.amiscript.AmiWebCalcTypesStack;import com.f1.ami.web.amiscript.AmiWebScriptMemberMethods;import com.f1.container.impl.BasicContainerTools;import com.f1.utils.CH;import com.f1.utils.IOH;import com.f1.utils.LH;import com.f1.utils.OH;import com.f1.utils.RH;import com.f1.utils.SH;import com.f1.utils.sql.SqlDerivedCellParser;import com.f1.utils.sql.SqlProcessor;import com.f1.utils.sql.TablesetImpl;import com.f1.utils.sql.aggs.AggMethodFactory;import com.f1.utils.sql.aggs.AggregateFactory;import com.f1.utils.sql.preps.AggregatePrepareFactory;import com.f1.utils.sql.preps.PrepMethodFactory;import com.f1.utils.string.SqlExpressionParser;import com.f1.utils.structs.BasicMultiMap;import com.f1.utils.structs.table.derived.BasicExternFactoryManager;import com.f1.utils.structs.table.derived.BasicMethodFactory;import com.f1.utils.structs.table.derived.DeclaredMethodFactory;import com.f1.utils.structs.table.derived.DerivedCellCalculator;import com.f1.utils.structs.table.derived.DerivedCellCalculatorConst;import com.f1.utils.structs.table.derived.DerivedCellMemberMethod;import com.f1.utils.structs.table.derived.MethodDerivedCellCalculator;import com.f1.utils.structs.table.derived.MethodExample;import com.f1.utils.structs.table.derived.MethodFactory;import com.f1.utils.structs.table.derived.ParamsDefinition;import com.f1.utils.structs.table.stack.CalcTypesStack;import com.f1.utils.structs.table.stack.EmptyCalcFrame;import com.f1.utils.structs.table.stack.EmptyCalcFrameStack;import com.f1.utils.structs.table.stack.EmptyCalcTypes;import com.f1.utils.structs.table.stack.MutableCalcFrame;import com.f1.utils.structs.table.stack.TopCalcFrameStack;import com.f1.utils.tar.TarEntry;import com.f1.utils.tar.TarOutputStream;public class AmiWebDocsMain {	private static final Logger log = LH.get();	final private BasicMethodFactory methodFactory;	final private SqlProcessor sp;	final private String endBlock = "\n\n";	final private String endLine = "\n";	final private SqlDerivedCellParser parser;	final private CalcTypesStack cts;	public AmiWebDocsMain(BasicMethodFactory methodFactory) {		this.methodFactory = methodFactory;		this.sp = new SqlProcessor();		SqlProcessor sqlProcessor = new SqlProcessor();		SqlExpressionParser expressionParser = sqlProcessor.getExpressionParser();		BasicExternFactoryManager externFactory = new BasicExternFactoryManager();		externFactory.addLanguage("python", new PythonExtern());		BasicContainerTools tools = new BasicContainerTools();		this.parser = new AmiWebAmiScriptDerivedCellParser(expressionParser, sqlProcessor, tools, externFactory, "docs", true);		this.cts = new AmiWebCalcTypesStack(null, EmptyCalcTypes.INSTANCE, EmptyCalcFrame.INSTANCE, methodFactory, new MutableCalcFrame());	}	public static void main(String a[]) throws IOException {		String outputTarfile = a[0];		String inputNavfile = a[1];		String outputNavfile = inputNavfile.split(".yml")[0] + "_built.yml";		String version = AmiStartup.getBuildProperty(AmiStartup.BUILD_PROPERTY_VERSION);		BasicMethodFactory methodFactory = new BasicMethodFactory();		methodFactory.addFactoryManager(AmiUtils.METHOD_FACTORY);		AmiWebScriptMemberMethods.registerMethods(null, methodFactory);		for (MethodFactory s : AggregateFactory.AGG_METHOD_FACTORIES.values()) {			methodFactory.addFactory(s);		}		for (MethodFactory s : AggregatePrepareFactory.PREP_METHOD_FACTORIES.values()) {			methodFactory.addFactory(s);		}		AmiWebDocsMain awdm = new AmiWebDocsMain(methodFactory);		BasicMultiMap.List<String, String> fileMap = new BasicMultiMap.List<String, String>();		IOH.writeData(new File(outputTarfile), awdm.buildDoc(fileMap));		IOH.writeText(new File(outputNavfile), awdm.buildNav(fileMap, inputNavfile));	}	public byte[] buildDoc(BasicMultiMap.List<String, String> fileMap) throws IOException {		ByteArrayOutputStream out = new ByteArrayOutputStream();		TarOutputStream tar = new TarOutputStream(out);		PrintStream tarPrintStream = new PrintStream(tar);		List<MethodFactory> sink = new ArrayList<MethodFactory>();		methodFactory.getAllMethodFactories(sink);		StringBuilder sb = new StringBuilder();		for (MethodFactory s : sink) {			if (s instanceof DeclaredMethodFactory)				continue;			ParamsDefinition def = s.getDefinition();			SH.clear(sb).append(def.getMethodName()).append("(");			for (int i = 0; i < def.getParamsCount(); i++) {				if (i != 0)					sb.append(",");				sb.append(def.getParamName(i));			}			sb.append(')');			String fileName = SH.toStringAndClear(sb);			sb.append("# ").append(fileName).append(endBlock);			buildDocumentation(s, s.getDefinition(), sb);			String filePath = "methods/" + fileName + ".md";			if (s instanceof PrepMethodFactory) {				filePath = "prepare_methods/" + fileName + ".md";			} else if (s instanceof AggMethodFactory) {				filePath = "aggregate_methods/" + fileName + ".md";			}			TarEntry entry = new TarEntry(filePath, false);			fileMap.putMulti(filePath.split("/")[0], filePath);			tar.putNextEntry(entry);			tarPrintStream.print(sb);			tarPrintStream.flush();			tar.closeEntry();		}		List<DerivedCellMemberMethod<Object>> methodsAll = new ArrayList<DerivedCellMemberMethod<Object>>();		methodFactory.getMemberMethods(null, null, methodsAll);		BasicMultiMap.List<Class<?>, DerivedCellMemberMethod<?>> map = new BasicMultiMap.List<Class<?>, DerivedCellMemberMethod<?>>();		Set<Class<?>> classSink = new HashSet<Class<?>>();		methodFactory.getTypes(classSink);		for (Class<?> clazz : classSink)			map.put(clazz, new ArrayList<DerivedCellMemberMethod<?>>());		for (DerivedCellMemberMethod<Object> method : methodsAll)			map.putMulti(method.getTargetType(), method);		StringBuilder sb2 = new StringBuilder();		for (Entry<Class<?>, List<DerivedCellMemberMethod<?>>> classObject : map.entrySet()) {			SH.clear(sb);			String fileName = methodFactory.forType(classObject.getKey());			sb.append("# ").append(fileName).append(endBlock);			buildDocumentation(classObject.getKey(), sb);			ArrayList<DerivedCellMemberMethod<Object>> methodsSink = new ArrayList<DerivedCellMemberMethod<Object>>();			methodFactory.getMemberMethods(classObject.getKey(), null, methodsSink);			Collections.sort(methodsSink, new Comparator<DerivedCellMemberMethod>() {				@Override				public int compare(DerivedCellMemberMethod o1, DerivedCellMemberMethod o2) {					return OH.compare(o1.getMethodName(), o2.getMethodName());				}			});			if (methodsSink.size() > 0)				sb.append("## Method Definitions").append(endBlock);			for (DerivedCellMemberMethod<Object> method : methodsSink) {				sb.append("---").append(endBlock);				sb.append("### ").append(getMemberTitle(method)).append(endBlock);				buildDocumentation((AmiAbstractMemberMethod) method, sb, classObject.getKey());			}			TarEntry entry = new TarEntry("classes/" + fileName + ".md", false);			fileMap.putMulti("classes", "classes/" + fileName + ".md");			tar.putNextEntry(entry);			tarPrintStream.print(sb);			tarPrintStream.flush();			tar.closeEntry();		}		tar.close();		return out.toByteArray();	}	public String buildNav(BasicMultiMap.List<String, String> fileMap, String inputNavfile) throws IOException {		String nav = IOH.readText(new File(inputNavfile));		String[] topLevel = nav.split("\n  - ");		int webLoc = -1;		for (int i = 0; i < topLevel.length; i++) {			if (topLevel[i].startsWith("Reference:")) {				webLoc = i;				break;			}		}		if (webLoc == -1)			return "";		StringBuilder sb = new StringBuilder(topLevel[webLoc]);		List<String> classList = fileMap.get("classes");		Collections.sort(classList);		sb.append("\n     - Classes:");		for (String clazz : classList) {			sb.append("\n        - 'javadoc/").append(clazz).append("'");		}		List<String> methodList = fileMap.get("methods");		Collections.sort(methodList);		sb.append("\n     - Methods:");		for (String method : methodList) {			sb.append("\n        - 'javadoc/").append(method).append("'");		}		List<String> aggMethodList = fileMap.get("aggregate_methods");		Collections.sort(aggMethodList);		sb.append("\n     - Aggregate Methods:");		for (String method : aggMethodList) {			sb.append("\n        - 'javadoc/").append(method).append("'");		}		List<String> prepMethodList = fileMap.get("prepare_methods");		Collections.sort(prepMethodList);		sb.append("\n     - Prepare Methods:");		for (String method : prepMethodList) {			sb.append("\n        - 'javadoc/").append(method).append("'");		}		topLevel[webLoc] = sb.toString();		return String.join("\n  - ", topLevel);	}	private void addClassLink(StringBuilder sb, Class clazz) {		addClassLink(sb, methodFactory.forType(clazz));	}	private void addClassLink(StringBuilder sb, String t) {		sb.append("[").append(t).append("](../classes/").append(t).append(".md)");	}	private void addMemberLink(StringBuilder sb, String t, String s) {		String cleanS = s.toLowerCase().replace("(", "").replace(")", "").replace(",", "");		String prettyS = s.replace(",", ", ");		sb.append("[").append(prettyS).append("](../classes/").append(t).append(".md#").append(cleanS).append(")");	}	private String getMemberTitle(DerivedCellMemberMethod<?> method) {		StringBuilder sb = new StringBuilder();		SH.clear(sb).append(OH.noNull(method.getMethodName(), "constructor")).append("(");		String[] t = method.getParamNames();		for (int i = 0; i < t.length; i++) {			if (i != 0)				sb.append(",");			sb.append(t[i]);		}		sb.append(')');		return sb.toString();	}	private void buildDocumentation(AmiAbstractMemberMethod data, StringBuilder sb, Class parentClass) {		if (data.getMethodName() != null) {			addClassLink(sb, data.getReturnType());			sb.append(' ');			addClassLink(sb, data.getTargetType());			sb.append("::").append(data.getMethodName());		} else {			addClassLink(sb, data.getTargetType());			sb.append(' ');			sb.append(methodFactory.forType(data.getTargetType()).toLowerCase());			sb.append(" = new ");			addClassLink(sb, data.getTargetType());		}		sb.append("(");		Class[] paramTypes = data.getParamTypes();		String[] paramNames = data.getParamNames();		for (int i = 0; i < paramNames.length; i++) {			if (i > 0)				sb.append(", ");			if (i == paramTypes.length) {				addClassLink(sb, data.getVarArgType());				sb.append(" ... ");			} else {				addClassLink(sb, paramTypes[i]);				sb.append(' ');			}			sb.append(data.getParamNames()[i]);		}		sb.append(")").append(endBlock);		String description = data.getDescription();		if (SH.is(description)) {			sb.append("#### Description").append(endBlock);			sb.append(SH.replaceAll(description, ":mm:", "\\:mm\\:")).append(endBlock);		}		if (paramNames.length > 0) {			sb.append("#### Parameter Definition").append(endBlock);			sb.append("| Name | Type | Description |").append(endLine);			sb.append("| ---- | ---- | ----------- |").append(endLine);			for (int i = 0; i < paramNames.length; i++) {				sb.append("| ").append(paramNames[i]).append(" | ");				if (i == paramTypes.length) {					addClassLink(sb, data.getVarArgType());					sb.append("&nbsp;...&nbsp;");				} else {					addClassLink(sb, paramTypes[i]);					sb.append("&nbsp;");				}				sb.append(" | ");				String des = data.getParamDescriptions()[i];				if (SH.is(des) && OH.ne(des, paramNames[i]))					sb.append(des);				sb.append(" |").append(endLine);			}		}		sb.append(endBlock);		MethodExample[] examples = data.getExamples();		if (examples.length > 0) {			for (int i = 0; i < examples.length; i++) {				if ((!SH.equals(examples[i].getOwningClass(), methodFactory.forType(parentClass))) && SH.is(examples[i].getOwningClass()))					continue;				sb.append("#### Example ").append(i + 1).append(endBlock);				sb.append("``` amiscript").append(endBlock);				sb.append(examples[i].getScript()).append(endLine);				String[] returns = examples[i].getReturns();				String[] evaluableScripts = examples[i].getEvaluableScripts();				for (int j = 0; j < returns.length; j++) {					Object result = parser.toCalc(evaluableScripts[j], cts).get(EmptyCalcFrameStack.INSTANCE);					String evaluation = result == null ? "null" : result.toString();					sb.append("// ").append(returns[j]).append(" = ").append(evaluation).append(endLine);				}				sb.append("```").append(endBlock);				String exampleDescription = examples[i].getDescription();				if (SH.isntEmpty(exampleDescription)) {					sb.append(exampleDescription).append(endBlock);				}			}		}	}	private void buildDocumentation(Class data, StringBuilder sb) {		Set<Class<?>> allTypes = new LinkedHashSet<Class<?>>();		methodFactory.getTypes(allTypes);		sb.append("## Definition").append(endBlock);		sb.append("```").append(endLine);		String type = methodFactory.forType(data);		sb.append(type).append(" var = .... ;").append(endLine);		sb.append("```").append(endBlock);		{			sb.append("#### Extends").append(endBlock);			LinkedHashSet<Class<?>> classes = new LinkedHashSet<Class<?>>();			RH.getImplementedClassesAndInterfaces(data, classes);			classes.add(Object.class);			for (Class<?> i : classes) {				if (allTypes.contains(i)) {					sb.append("-   ");					addClassLink(sb, i);					sb.append(endLine);				}			}			sb.append(endBlock);		}		{			sb.append("#### Extended By").append(endBlock);			boolean extended = false;			for (Class<?> i : allTypes) {				if (data != i && OH.isAssignableFrom(data, i)) {					extended = true;					sb.append("-   ");					addClassLink(sb, i);					sb.append(endLine);				}			}			if (!extended)				sb.append("None").append(endBlock);		}		String description = methodFactory.getVarTypeDescription(type);		if (SH.is(description)) {			sb.append("## Description").append(endBlock);			sb.append(description).append(endBlock);		}		List<ParamsDefinition> callbacks = null;//TODO: service.getScriptManager().getCallbackDefinitions(data);		if (CH.isntEmpty(callbacks)) {			sb.append("## Custom Callbacks");			sb.append("<table style='border-collapse:collapse'>");			sb.append("<tr style='min-height:11pt;'>");			sb.append("<td style='border:1px solid grey'><B>Returns&nbsp;");			sb.append("<td style='border:1px solid grey'><B>Name&nbsp;");			sb.append("<td style='border:1px solid grey'><B>Description&nbsp;");			for (ParamsDefinition i : callbacks) {				sb.append("<tr style='min-height:11pt;'><td style='border:1px solid grey'>&nbsp;");				addClassLink(sb, i.getReturnType());				sb.append("&nbsp;<td style='border:1px solid grey'>&nbsp;");				String cb = "todo:callback";				sb.append("<A href='#' onclick=").append(cb).append(">");				sb.append(OH.noNull(i.getMethodName(), "&lt;Constructor&gt;"));				sb.append("</a>&nbsp;<td style='border:1px solid grey;min-width:100px'>");				sb.append(i.getDescriptionHtml());			}			sb.append("</tr>");			sb.append("</table>");		}		sb.append("## Method Summary").append(endBlock);		sb.append("| Owner | Name | Return Type | Description |").append(endLine);		sb.append("| ----- | ---- | ----------- | ----------- |").append(endLine);		List<DerivedCellMemberMethod<Object>> sink = new ArrayList<DerivedCellMemberMethod<Object>>();		methodFactory.getMemberMethods(data, null, sink);		Collections.sort(sink, new Comparator<DerivedCellMemberMethod>() {			@Override			public int compare(DerivedCellMemberMethod o1, DerivedCellMemberMethod o2) {				return OH.compare(o1.getMethodName(), o2.getMethodName());			}		});		for (DerivedCellMemberMethod<Object> i : sink) {			sb.append("| ");			addClassLink(sb, i.getTargetType());			String name = getMemberTitle(i);			sb.append(" | ");			addMemberLink(sb, type, name);			sb.append(" | ");			addClassLink(sb, i.getReturnType());			sb.append(" | ");			if (i instanceof AmiAbstractMemberMethod) {				AmiAbstractMemberMethod i2 = (AmiAbstractMemberMethod) i;				sb.append(SH.replaceAll(i2.getDescription(), ":mm:", "\\:mm\\:")); //replace ":mm:" with "\:mm\:" so it is not rendered as a country flag			}			sb.append(" |").append(endLine);		}		sb.append(endBlock);	}	private void buildDocumentation(MethodFactory function, ParamsDefinition def, StringBuilder sb) {		sb.append("## Definition").append(endBlock);		addClassLink(sb, def.getReturnType());		sb.append(' ');		sb.append(AmiWebUtils.getFunctionDescription(methodFactory, def)).append(endBlock);		String description = def.getDescriptionHtml();		if (SH.is(description)) {			sb.append("## Description").append(endBlock);			sb.append(description).append(endBlock);		}		int paramsCount = def.getParamsCount();		if (paramsCount > 0) {			sb.append("## Parameter Definition").append(endBlock);			sb.append("| Name | Type | Description |").append(endLine);			sb.append("| ---- | ---- | ----------- |").append(endLine);			for (int i = 0; i < paramsCount; i++) {				sb.append("| ").append(def.getParamName(i)).append(" | ");				addClassLink(sb, def.getParamType(i));				if (def.isVarArg() && i == paramsCount - 1)					sb.append("...");				sb.append(" | ");				String des = def.getParamDescriptionHtml(i);				if (SH.is(des))					sb.append(des);				sb.append(" |").append(endLine);			}			sb.append(endBlock);		}		if (function != null) {			// Build simple examples			Object[][] ex = def.getExamples();			if (ex.length > 0) {				sb.append("## Examples").append(endBlock);				sb.append("```").append(endLine);				int i = 0;				for (Object o[] : ex) {					i++;					MethodDerivedCellCalculator func = (MethodDerivedCellCalculator) function.toMethod(0, def.getMethodName(), toConsts(o, def), EmptyCalcFrameStack.INSTANCE);					Object value = func.get(EmptyCalcFrameStack.INSTANCE);					sb.append(methodFactory.forType(value == null ? Object.class : value.getClass()));					sb.append(" r").append(i).append(" = ");					toString(func, sb);					sb.append("; // r").append(i).append(" == ").append(value).append(endLine);				}				sb.append("```").append(endLine);			}		}		// Build advanced examples		MethodExample[] examples = def.getAdvancedExamples();		if (examples.length > 0) {			for (int i = 0; i < examples.length; i++) {				sb.append("## Example ").append(i + 1).append(endBlock);				sb.append("``` amiscript").append(endLine);				sb.append(examples[i].getScript()).append(endLine).append(endLine);				String[] returns = examples[i].getReturns();				String[] evaluableScripts = examples[i].getEvaluableScripts();				for (int j = 0; j < returns.length; j++) {					Object result = parser.toCalc(evaluableScripts[j], cts).get(new TopCalcFrameStack(new TablesetImpl(), EmptyCalcFrame.INSTANCE));					String evaluation = result == null ? "null" : result.toString();					sb.append("// ").append(returns[j]).append(" = ");					if (evaluation.contains(endLine))						sb.append(endLine).append("// ");					sb.append(evaluation.replaceAll(endLine, endLine + "// ")).append(endLine);				}				sb.append("```").append(endBlock);				String exampleDescription = examples[i].getDescription();				if (SH.isntEmpty(exampleDescription)) {					sb.append(exampleDescription).append(endBlock);				}			}		}	}	public DerivedCellCalculator[] toConsts(Object[] o, ParamsDefinition def) {		DerivedCellCalculator[] r = new DerivedCellCalculator[o.length];		for (int i = 0; i < r.length; i++) {			Class<?> paramType = def.getParamType(Math.min(i, def.getParamsCount() - 1));			r[i] = new DerivedCellCalculatorConst(0, paramType.cast(o[i]),					o[i] == null && (i < def.getParamsCount() - 1 || !def.isVarArg()) ? paramType : (o[i] == null ? paramType : o[i].getClass()));		}		return r;	}	private StringBuilder toString(MethodDerivedCellCalculator func, StringBuilder sink) {		sink.append(func.getMethodName());		//		DerivedCellCalculator[] params = func.getPa();		int paramsCount = func.getParamsCount();		if (paramsCount == 0)			return sink.append("()");		for (int i = 0; i < paramsCount; i++) {			sink.append(i == 0 ? '(' : ',');			Object value = func.getParamAt(i).get(null);			if (value instanceof List) {				sink.append("new List(");				List t = (List) value;				for (int n = 0; n < t.size(); n++) {					if (n > 0)						sink.append(", ");					AmiUtils.toConstString(t.get(n), sink);				}				sink.append(")");			} else if (value instanceof Set) {				sink.append("new Set(");				Set t = (Set) value;				boolean first = true;				for (Object v : t) {					if (first)						first = false;					else						sink.append(", ");					AmiUtils.toConstString(v, sink);				}				sink.append(")");			} else if (value instanceof Map) {				sink.append("new Map(");				Map<Object, Object> t = (Map) value;				boolean first = true;				for (Map.Entry<Object, Object> v : t.entrySet()) {					if (first)						first = false;					else						sink.append(", ");					AmiUtils.toConstString(v.getKey(), sink);					sink.append(", ");					AmiUtils.toConstString(v.getValue(), sink);				}				sink.append(")");			} else				func.getParamAt(i).toString(sink);		}		return sink.append(')');	}}