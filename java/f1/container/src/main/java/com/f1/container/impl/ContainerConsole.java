package com.f1.container.impl;import java.util.ArrayList;import java.util.Date;import java.util.IdentityHashMap;import java.util.List;import java.util.Map;import com.f1.base.Action;import com.f1.base.Console;import com.f1.base.Table;import com.f1.base.Valued;import com.f1.base.ValuedParam;import com.f1.base.ValuedSchema;import com.f1.container.Container;import com.f1.container.ContainerConstants;import com.f1.container.ContainerScope;import com.f1.container.ContainerServices;import com.f1.container.Partition;import com.f1.container.PartitionController;import com.f1.container.Port;import com.f1.container.Processor;import com.f1.container.StartStoppable;import com.f1.container.State;import com.f1.container.Suite;import com.f1.container.ThreadScope;import com.f1.container.exceptions.ContainerException;import com.f1.container.impl.dispatching.PartitionActionEvent;import com.f1.container.impl.dispatching.PartitionActionRunner;import com.f1.container.impl.dispatching.RootPartitionActionRunner;import com.f1.container.impl.dispatching.RootPartitionStats;import com.f1.utils.Formatter;import com.f1.utils.LocaleFormatter;import com.f1.utils.OH;import com.f1.utils.SH;import com.f1.utils.TableHelper;import com.f1.utils.ack.CountdownAcker;import com.f1.utils.impl.BasicLabeler;import com.f1.utils.structs.table.BasicTable;@Console(name = "Container", help = "Provides runtime access to the f1 container")public class ContainerConsole {	final private Container container;	public ContainerConsole(Container container) {		this.container = container;	}	public Container getContainer() {		return container;	}	@Console(help = "provides diagnostics of all container scopes under supplied path", params = { "containerScopePath" })	public String diagnose(String path) {		ContainerScope cs = getContainerScope(path);		if (cs == null)			return "container scope not found: " + path;		return ContainerHelper.diagnose(cs);	}	@Console(help = "provides diagnostics of the dispatcher")	public String diagnoseDispatcher() {		return ContainerHelper.diagnose(container.getDispatchController());	}	@Console(help = "provides diagnostics of all container scopes")	public String diagnose() {		List<ContainerScope> sink = new ArrayList<ContainerScope>();		ContainerHelper.getAllChildren(container, sink);		StringBuilder sb = new StringBuilder();		for (ContainerScope cs : sink) {			sb.append("**");			SH.centerAlign('*', " " + cs.getFullName() + " ", 80, false, sb);			sb.append("**").append(SH.NEWLINE);			sb.append(ContainerHelper.diagnose(cs));			sb.append(SH.NEWLINE);		}		return sb.toString();	}	@Console(help = "call a processor at the supplied path.  Will block until timeout is reached, or action is acked.\nAn Action of the expected type by the receiving processor will automatically be created.  The params are populated using the keyValues array.\n keyValues should be key,value,key,value,... ", params = {			"containerScopePath" })	public String callProcessor(String path, long ackTimeout, Object... keyValues) {		if (keyValues.length % 2 != 0)			return "must be even number of key/value pairs: " + keyValues.length;		path = SH.stripPrefix(path, container.getSuiteController().getRootSuite().getFullName() + "/", false);		ContainerScope cs = container.getSuiteController().getRootSuite().getChild(path);		if (cs == null)			return "container scope not found in suite controller: " + path + "   (call showContainerScopes() for existing list)";		Port port;		if (cs instanceof Port)			port = (Port) cs;		else if (cs instanceof Processor)			port = ((Processor) cs).getInputPort();		else			throw new ContainerException(cs, "can not send messages to destination");		Processor processor = port.getProcessor();		Action action = (Action) container.nw(processor.getActionType());		ValuedSchema<Valued> schema = action.askSchema();		for (int i = 0; i < keyValues.length; i += 2) {			ValuedParam<Valued> p = schema.askValuedParam((String) keyValues[i]);			p.setValue(action, p.getCaster().cast(keyValues[i + 1]));		}		CountdownAcker acker = null;		if (ackTimeout > 0) {			acker = new CountdownAcker(1);			action.registerAcker(acker);		}		container.getDispatchController().dispatch(port, processor, action, null, null);		if (acker != null) {			if (acker.waitForAcks(ackTimeout))				return "ack response: " + acker.getAcks().get(0).getB();			else				return "timeout exceeded";		}		return "message sent";	}	@Console(help = "Returns a list of all registered processors")	public String showProcessors() {		StringBuilder sb = new StringBuilder();		String prefix = container.getRootSuite().getFullName() + ContainerConstants.NAME_SEPERATOR;		for (ContainerScope child : ContainerHelper.getAllChildren(container.getRootSuite()))			if (child instanceof Processor)				sb.append(SH.stripPrefix(child.getFullName(), prefix, false)).append(SH.NEWLINE);		return sb.toString();	}	@Console(help = "Returns a container scope at the supplied path", params = { "containerScopePath" })	public ContainerScope getContainerScope(String path) {		String prefix = container.getFullName();		if (prefix.equals(path))			return container;		prefix += "/";		if (!path.startsWith(prefix))			return null;		return container.getChild(path.substring(prefix.length()));	}	@Console(help = "Shows the details of a container scope at a particular path", params = { "containerScopePath" })	public String showContainerScope(String path) {		ContainerScope cs = getContainerScope(path);		if (cs == null)			return "container scoped not found:" + path;		final Formatter formatter = container.getServices().getLocaleFormatter().getDateFormatter(LocaleFormatter.DATETIME);		StringBuilder sb = new StringBuilder();		sb.append("   Full path: ").append(cs.getFullName()).append(SH.NEWLINE);		sb.append("  Class type: ").append(cs.getClass().getName()).append(SH.NEWLINE);		sb.append("       state: ").append(cs.isStarted() ? "started" : "stopped").append(SH.NEWLINE);		long startedMs = cs.getStartedMs();		sb.append("Started time: ").append(startedMs == StartStoppable.NO_TIME ? "N/A" : formatter.format(new Date(startedMs))).append(SH.NEWLINE);		return sb.toString();	}	@Console(help = "Shows the details of all container scope instances")	public String showContainerScopes() {		Table table = new BasicTable(String.class, "#", String.class, "dest #", String.class, "Type", String.class, "Path", String.class, "state");		List<ContainerScope> allChildren = ContainerHelper.getAllChildren(container);		Map<ContainerScope, Integer> ids = new IdentityHashMap<ContainerScope, Integer>();		List<ContainerScope> children = new ArrayList<ContainerScope>(allChildren.size());		for (int i = 0; i < allChildren.size(); i++) {			ContainerScope child = allChildren.get(i);			ids.put(child, children.size());			children.add(child);		}		for (ContainerScope cs : children) {			String description;			String destId = "";			if (cs instanceof Suite)				description = "Suite";			else if (cs instanceof Port) {				description = "Port";				Port<?> p = (Port) cs;				if (!p.isInput()) {					Processor processor = ((Port<?>) p).getProcessor();					Integer dest = ids.get(processor);					if (dest != null) {						if (destId != "")							destId += ", ";						destId += dest.toString();					}				}			} else if (cs instanceof Processor)				description = "Processor";			else				description = "ContainerScope";			table.getRows().addRow(SH.toString(cs.getContainerScopeUid()), destId, description, cs.getFullName(), cs.isStarted() ? "started" : "stopped");		}		String tableText = TableHelper.toString(table, "", TableHelper.SHOW_ALL ^ TableHelper.SHOW_TYPES, new StringBuilder()).toString();		return tableText;	}	@Console(help = "returns a table of all partitions in the container")	public Table showPartitions() {		final Table t = new BasicTable(String.class, "id", String.class, "startTime", String.class, "threadpoolId", int.class, "states", int.class, "actions", long.class, "queued",				long.class, "timeSpentMs", int.class, "exceptions", boolean.class, "writeLocked", boolean.class, "inThreadPool");		final PartitionController pc = container.getPartitionController();		final Formatter formatter = container.getServices().getLocaleFormatter().getDateFormatter(LocaleFormatter.DATETIME);		RootPartitionStats stats = new RootPartitionStats();		for (Object partitionId : pc.getPartitions()) {			Partition partition = pc.getPartition(partitionId);			if (partition == null)				continue;			RootPartitionActionRunner rpr = container.getDispatchController().getRootPartitionRunner((String) partition.getPartitionId());			int throwables = 0;			for (Object o : partition.getStateTypes()) {				State s = partition.getState(o);				if (s == null)					continue;				BasicStatePeer p = (BasicStatePeer) s.getPeer();				throwables += p.countThrowables;			}			long queued = partition.getQueueSize();			if (rpr != null)				rpr.getStats(stats);			else {				stats.setQueueRuns(0);				stats.setActionsProcessed(0);				stats.setTimeSpentMs(-1);				stats.setInThreadPool(false);				stats.setActionsAdded(0);			}			t.getRows().addRow(partitionId.toString(), rpr == null ? null : formatter.format(new Date(rpr.getStartTime())), partition.getThreadPoolKey(),					partition.getStateTypes().size(), stats.getActionsProcessed(), queued, stats.getTimeSpentMs(), throwables, partition.isWriteLocked(), stats.getInThreadPool());		}		TableHelper.sort(t, SH.split(',', "actions"));		return t;	}	@Console(help = "returns a table of all states in the container")	public Table showStates() {		final Table t = new BasicTable(String.class, "partitionId", Object.class, "stateType", String.class, "startTime", String.class, "threadpoolId", int.class, "actions",				int.class, "exceptions", String.class, "toString");		final PartitionController pc = container.getPartitionController();		final Formatter formatter = container.getServices().getLocaleFormatter().getDateFormatter(LocaleFormatter.DATETIME);		for (Object partitionId : pc.getPartitions()) {			Partition partition = pc.getPartition(partitionId);			if (partition == null)				continue;			for (Object o : partition.getStateTypes()) {				State s = partition.getState(o);				if (s == null)					continue;				BasicStatePeer p = (BasicStatePeer) s.getPeer();				t.getRows().addRow(partitionId.toString(), o, formatter.format(new Date(p.createdMs)), partition.getThreadPoolKey(), p.countProcessAction, p.countThrowables,						s.toString());			}		}		TableHelper.sort(t, SH.split(',', "actions"));		return t;	}	@Console(help = "returns a table of all messages in queue", params = { "partitionId" })	public Table showQueue(String partitionId) {		final Table t = new BasicTable(String.class, "Type", int.class, "Position", String.class, "Action", String.class, "Source", String.class, "Target");		RootPartitionActionRunner rpr = container.getDispatchController().getRootPartitionRunner(partitionId);		if (rpr == null)			return null;		List<PartitionActionEvent<?>> sink = new ArrayList<PartitionActionEvent<?>>();		for (PartitionActionRunner runner : rpr.getRunners()) {			sink.clear();			runner.getQueuedEvents(sink);			String runnerName = OH.getSimpleClassName(runner);			int position = 0;			for (PartitionActionEvent<?> pae : sink) {				Processor<?, ?> p = pae.processor;				Port<?> s = pae.sourcePort;				Object a = pae.action;				t.getRows().addRow(runnerName, OH.getSimpleClassName(a), position++, OH.getSimpleClassName(s == null ? null : s.getProcessor()), OH.getSimpleClassName(p));			}		}		return t;	}	@Console(help = "returns a table of all threads in the container")	public Table showThreads() {		final Table t = new BasicTable(String.class, "thPoolId", Object.class, "thId", String.class, "startTime", String.class, "thState", Long.class, "calls", Long.class,				"errors", String.class, "processor", Object.class, "partitionId", String.class, "Notes");		final Formatter formatter = container.getServices().getLocaleFormatter().getDateFormatter(LocaleFormatter.DATETIME);		for (ThreadScope ts : container.getThreadScopeController().getThreadScopes()) {			final BasicThreadScope bts = (BasicThreadScope) ts;			final long runCount = bts.getRunCount();			final long errorCount = bts.getErrorCount();			final Processor processor = bts.getCurrentProcessor();			final String processorName = processor == null ? "" : processor.getFullName();			final State state = bts.getCurrentState();			final Object pid = state == null || state.getPartition() == null ? "" : state.getPartition().getPartitionId();			java.lang.Thread.State threadState = bts.getState();			final long runCount2 = bts.getRunCount();			final String notes = runCount == runCount2 ? "" : "Concurrent modification while inspecting: data may be inconsistent.";			t.getRows().addRow(bts.getThreadPoolKey(), bts.getName(), formatter.format(new Date(bts.getStartTimeMillis())), threadState.toString(), runCount, errorCount,					processorName, pid, notes);		}		return t;	}	@Console(help = "start up the container")	public String start() {		container.start();		return "container started okay: " + container.getFullName();	}	@Console(help = "stop the container")	public String stop() {		container.stop();		return "container stopped okay: " + container.getFullName();	}	@Console(help = "show list of all available services, see getService(...)")	public String showServices() {		BasicLabeler labeler = new BasicLabeler();		ContainerServices services = container.getServices();		for (String name : services.getServiceNames()) {			labeler.addItem(name, SH.toString(services.getService(name)), true);		}		return labeler.toString();	}	@Console(help = "gets the service associated to the supplied name", params = { "serviceName" })	public Object getService(String serviceName) {		return container.getServices().getService(serviceName);	}}