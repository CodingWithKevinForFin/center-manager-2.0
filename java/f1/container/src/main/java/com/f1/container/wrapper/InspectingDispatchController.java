package com.f1.container.wrapper;import java.util.List;import java.util.concurrent.CopyOnWriteArrayList;import java.util.logging.Level;import java.util.logging.Logger;import com.f1.base.Action;import com.f1.container.DispatchController;import com.f1.container.Partition;import com.f1.container.Port;import com.f1.container.Processor;import com.f1.container.RequestMessage;import com.f1.container.ResultMessage;import com.f1.container.State;import com.f1.container.ThreadScope;import com.f1.container.inspect.DispatchInspector;import com.f1.utils.LH;public class InspectingDispatchController extends DispatchControllerWrapper {	private static final Logger log = Logger.getLogger(InspectingDispatchController.class.getName());	private List<DispatchInspector> inspectors = new CopyOnWriteArrayList<DispatchInspector>();	private volatile boolean hasInspectors = false;	public InspectingDispatchController(DispatchController inner) {		super(inner);	}	public void addInspector(DispatchInspector dispatchInspector) {		this.hasInspectors = true;		this.inspectors.add(dispatchInspector);	}	@Override	public Partition dispatch(Port<?> optionalSourcePort, Processor<?, ?> processor, Action action, Object partitionId, long delayMs, ThreadScope threadScope) {		Partition r = super.dispatch(optionalSourcePort, processor, action, partitionId, delayMs, threadScope);		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onDispatch(this, optionalSourcePort, processor, action, threadScope, r, delayMs);				} catch (Exception e) {					onException(e);				}			}		}		return r;	}	@Override	public Partition dispatch(Port<?> optionalSourcePort, Processor<?, ?> processor, Action action, Object partitionId, ThreadScope threadScope) {		Partition r = super.dispatch(optionalSourcePort, processor, action, partitionId, threadScope);		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onDispatch(this, optionalSourcePort, processor, action, threadScope, r, 0);				} catch (Exception e) {					onException(e);				}			}		}		return r;	}	@Override	public void forward(Port<?> optionalSourcePort, Processor<?, ?> processor, Action action, ThreadScope scope) {		super.forward(optionalSourcePort, processor, action, scope);		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onForward(this, optionalSourcePort, processor, action, scope);				} catch (Exception e) {					onException(e);				}			}		}	}	@Override	public boolean onPartitionAdded(Partition partition) {		if (!super.onPartitionAdded(partition))			return false;		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onPartitionAdded(this, partition);				} catch (Exception e) {					onException(e);				}			}		}		return true;	}	@Override	public void handleThrowableFromProcessor(Processor<?, ?> processor, Action action, State state, ThreadScope thread, Throwable t) {		super.handleThrowableFromProcessor(processor, action, state, thread, t);		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onThrown(this, processor, action, thread, state, t);				} catch (Exception e) {					onException(e);				}			}		}	}	@Override	public void reply(Port<?> optionalSourcePort, RequestMessage<?> request, ResultMessage<?> result, ThreadScope threadScope) {		super.reply(optionalSourcePort, request, result, threadScope);		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onReply(this, optionalSourcePort, request, result, threadScope);				} catch (Exception e) {					onException(e);				}			}		}	}	@Override	public State createState(Partition partition, Processor processor, Action action) {		return super.createState(partition, processor, action);	}	@Override	public <A extends Action, S extends State> void safelyProcess(Port<?> optionalSourcePort, Processor<? super A, ? super S> processor, A action, S state,	ThreadScope threadScope, boolean isDispatch) {		super.safelyProcess(optionalSourcePort, processor, action, state, threadScope, isDispatch);		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onProcess(this, optionalSourcePort, processor, action, state, threadScope);				} catch (Exception e) {					onException(e);				}			}		}	}	private void onException(Exception e) {		LH.info(log,  "Exception thrown by inspector", e);	}	@Override	public void start() {		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onStart(this);				} catch (Exception e) {					onException(e);				}			}		}		super.start();	}	@Override	public void stop() {		if (hasInspectors) {			for (DispatchInspector inspector : inspectors) {				try {					inspector.onStop(this);				} catch (Exception e) {					onException(e);				}			}		}		super.stop();	}}