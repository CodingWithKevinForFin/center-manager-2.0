package com.f1.fix.oms.sliceside;

import java.util.logging.Level;

import com.f1.base.DateNanos;
import com.f1.base.ObjectGeneratorForClass;
import com.f1.container.ThreadScope;
import com.f1.fix.oms.OmsAbstractProcessor;
import com.f1.fix.oms.OmsUtils;
import com.f1.fix.oms.adapter.OmsOrderState;
import com.f1.fix.oms.plugin.CancelReplaceChildOrderPlugin;
import com.f1.fix.oms.schema.FixCopyUtil;
import com.f1.fix.oms.schema.OmsOrder;
import com.f1.fix.oms.schema.OmsOrderStatus;
import com.f1.fix.oms.schema.OrderEventCtx;
import com.f1.fix.oms.schema.Slice;
import com.f1.pofo.fix.ChildOrderId;
import com.f1.pofo.fix.MsgType;
import com.f1.pofo.fix.child.FixChildOrderReplaceRequest;
import com.f1.pofo.oms.ChildOrderRequest;
import com.f1.pofo.oms.OmsAction;
import com.f1.pofo.oms.OmsNotification;
import com.f1.pofo.oms.Order;
import com.f1.utils.LH;
import com.f1.utils.SH;

/**
 * process replace requests for a child order
 */

public class OmsDefaultReplaceChildOrderProcessor extends OmsAbstractProcessor {
	private ObjectGeneratorForClass<Slice> sg;
	private ObjectGeneratorForClass<FixChildOrderReplaceRequest> request;
	private ObjectGeneratorForClass<ChildOrderId> coid;
	private ObjectGeneratorForClass<Order> sfixg;
	private CancelReplaceChildOrderPlugin plugin;

	public void start() {
		super.start();
		sg = getGenerator(Slice.class);
		request = getGenerator(FixChildOrderReplaceRequest.class);
		coid = getGenerator(ChildOrderId.class);
		sfixg = getGenerator(Order.class);
		this.plugin = super.getOmsPlugin().getCancelReplaceChildOrderPlugin();
	}

	private String validateAndPopulate(ChildOrderRequest childRequest, Order fixOrder, OmsOrder parentOrder) {

		int orderQty = childRequest.getOrderQty();
		if (orderQty < fixOrder.getTotalExecQty())
			return "can not reduce quantity below filled quantity of " + fixOrder.getTotalExecQty();

		// TODO: check for valid : conditions
		// if parent order is market and child order is limit
		// if parent order is market and child order is market
		// if parent order is market and child order is market

		if (childRequest.getOrderType() == null)
			childRequest.setOrderType(fixOrder.getOrderType());
		if (zeroPrice(childRequest.getLimitPx()))
			childRequest.setLimitPx(fixOrder.getLimitPx());
		if (SH.isnt(childRequest.getCurrency()) && SH.is(fixOrder.getCurrency()))
			childRequest.setCurrency(fixOrder.getCurrency());
		if (childRequest.getTimeInForce() == null)
			childRequest.setTimeInForce(fixOrder.getTimeInForce());
		if (childRequest.getSide() == null)
			childRequest.setSide(fixOrder.getSide());
		if (childRequest.getExecInstructions() == null)
			childRequest.setExecInstructions(fixOrder.getExecInstructions());
		final int qtyIncrease = orderQty - fixOrder.getOrderQty();
		log.info("LIMITS: ------------------- ");//TODO:REMOVE 
		log.info("LIMITS: Quantity Increase: " + qtyIncrease);//TODO:REMOVE 
		if (qtyIncrease > 0) {
			final int remainingQuantity = parentOrder.getFixOrder().getOrderQty() - parentOrder.getExchLeaves() - parentOrder.getFixOrder().getTotalExecQty();
			log.info("LIMITS: Remaining Quantity: " + remainingQuantity);//TODO:REMOVE 
			if (qtyIncrease > remainingQuantity) {
				return "Child quantity increase exceeds remaining parent quantity: " + fixOrder.getOrderQty() + " ==> " + orderQty + " > " + remainingQuantity;
			}
			parentOrder.setExchLeaves(parentOrder.getExchLeaves() + qtyIncrease);
		}
		log.info("LIMITS: Exchange Leaves: " + parentOrder.getExchLeaves());//TODO:REMOVE 
		return null;
	}

	private boolean zeroPrice(double price) {
		return (Math.abs(price) < 0.00001);
	}

	@Override
	public void processAction(OrderEventCtx action, OmsOrderState state, ThreadScope threadScope) throws Exception {

		Slice orderToModify = (Slice) action.getOrder();
		if (orderToModify != null) {
			OmsOrder parent = orderToModify.getParentOrder();
			if (OmsUtils.isTerminal(parent.getOrderStatus())) {
				action.setRejectText("Cannot Replace Order when Parent Order is Terminal");
				return;
			}
		} else {
			action.setRejectText("Cannot find child order : " + action.getClientMsg().getOrderID());
			return;
		}
		// OrderID for the child order should be generated by the requestor
		// ClientOrder ID for the child order outbound will be a function of the
		// parent order id
		// TODO: Move destination up one and send only a FixRequestEvent
		final DateNanos now = getTools().getNowNanoDate();

		final ChildOrderRequest childRequest = action.getClientMsg().getChildRequest();
		// TODO: If request is null throw a fit;

		orderToModify.setPendingChildReplace(childRequest);

		String result = validateAndPopulate(childRequest, orderToModify.getFixOrder(), orderToModify.getParentOrder());
		if (result != null) {
			action.setRejectText(result);
			return;
		}

		final FixChildOrderReplaceRequest evt = request.nw();
		evt.setOrderInfo(childRequest);

		final Order fixorder = orderToModify.getFixOrder();
		final Order parentInfo = orderToModify.getParentOrder().getFixOrder();
		evt.setSymbol(parentInfo.getSymbol());
		evt.setSymbolSfx(parentInfo.getSymbolSfx());
		evt.setLocateBrokerRequired(parentInfo.getLocateBrokerRequired());
		evt.setLocateBroker(parentInfo.getLocateBroker());
		evt.setSenderSubId(parentInfo.getSenderSubId());
		evt.setLocateId(parentInfo.getLocateId());
		evt.setOrderCapacity(parentInfo.getOrderCapacity());
		evt.setRule80A(parentInfo.getRule80A());
		evt.setType(MsgType.REPLACE_REQUEST);
		fixorder.setRevision(fixorder.getRevision() + 1);
		fixorder.setUpdatedTime(now);

		OmsUtils.transitionSliceTo(orderToModify, OmsOrderStatus.PENDING_RPL);

		ChildOrderId id = FixCopyUtil.createRequest(this, orderToModify);

		evt.setSessionName(fixorder.getSessionName()); // This should be set by
														// a later processor
														// which handles all the
														// destinations etc.
		evt.setChildId(id);
		evt.setRootOrderId(state.getClientOrder().getFixOrder().getId());
		evt.setDestination(fixorder.getDestination());

		if (plugin != null) {
			try {
				plugin.onCancelReplaceChildOrder(parentInfo, fixorder, evt);
			} catch (Exception e) {
				LH.log(log, Level.SEVERE, "Plugin generated error for cancel child: ", request, e);
			}
		}

		getOmsPlugin().mapReplaceChildOrderTags(fixorder.getPassThruTags(), evt.getOrderInfo());
		toFixSession.send(evt, threadScope);
		OmsNotification notif = newNotification(state);
		notif.setType(OmsAction.REPLACE_CHILD_ORDER);
		toOMSClient.send(notif, threadScope);
	}

}
