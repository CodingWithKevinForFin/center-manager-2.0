package com.f1.qfix;import java.util.concurrent.ConcurrentMap;import com.f1.speedlogger.SpeedLoggerManager;import com.f1.utils.CopyOnWriteHashMap;import com.f1.utils.OH;import quickfix.Log;import quickfix.LogFactory;import quickfix.SessionID;public class QuickFixSpeedLoggerManager implements LogFactory {	final private String prefix;	final private SpeedLoggerManager inner;	final private int messageLevel;	final private int eventLevel;	final private int errorLevel;	private Log defaultLogger;	private ConcurrentMap<SessionID, QuickFixSpeedLogger> loggers = new CopyOnWriteHashMap<SessionID, QuickFixSpeedLogger>();	public QuickFixSpeedLoggerManager(SpeedLoggerManager inner, int messageLevel, int eventLevel, int errorLevel) {		this(inner, messageLevel, eventLevel, errorLevel, "QuickFix.");	}	public QuickFixSpeedLoggerManager(SpeedLoggerManager inner, int messageLevel, int eventLevel, int errorLevel, String prefix) {		this.prefix = prefix;		this.inner = inner;		this.messageLevel = messageLevel;		this.eventLevel = eventLevel;		this.errorLevel = errorLevel;	}	//@Override	public Log create() {		if (defaultLogger == null)			defaultLogger = new QuickFixSpeedLogger(inner.getLogger("QuickFix"), messageLevel, eventLevel, errorLevel);		return defaultLogger;	}	@Override	public Log create(SessionID sessionID) {		if (sessionID == null)			return create();		QuickFixSpeedLogger r = loggers.get(sessionID);		if (r == null) {			QuickFixSpeedLogger existing = loggers.putIfAbsent(sessionID,					r = new QuickFixSpeedLogger(inner.getLogger(prefix + OH.toString(sessionID)), messageLevel, eventLevel, errorLevel));			if (existing != null)				return existing;		}		return r;	}}