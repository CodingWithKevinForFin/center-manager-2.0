package com.f1.fixclientsim;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.Map;import com.f1.utils.CH;import quickfix.Message;import quickfix.Message.Header;import quickfix.Session;import quickfix.SessionID;import quickfix.SocketInitiator;import quickfix.field.MsgType;public class FixClientSimSession {	public static final byte CONNECTING = 0;	public static final byte CONNECTED = 1;	public static final byte DISCONNECTED = 2;	private final Session session;	private List<FixClientSimListener> listeners = new ArrayList<FixClientSimListener>();	private byte state = CONNECTING;	private SocketInitiator initiator;	private long uid;	public FixClientSimSession(long uid, SocketInitiator initiator, Session session) {		this.uid = uid;		this.initiator = initiator;		this.session = session;	}	synchronized public Message sendMessage(Map<Integer, String> header, Map<Integer, String> body) {		if (state != CONNECTED)			throw new IllegalStateException("not connected: " + session.getSessionID().toString());		final Message message = new Message();		final Header headerMessage = message.getHeader();		for (Map.Entry<Integer, String> e : body.entrySet())			message.setString(e.getKey(), e.getValue());		for (Map.Entry<Integer, String> e : header.entrySet())			headerMessage.setString(e.getKey(), e.getValue());		session.send(message);		return message;	}	synchronized public Message sendMessage42(String msgType, Map<Integer, String> m) {		return sendMessage((Map) CH.m(MsgType.FIELD, msgType), m);	}	synchronized public SessionID getSessionId() {		return session.getSessionID();	}	synchronized public void fireOnMessage(Message message) {		for (FixClientSimListener listener : listeners)			listener.onMessage(this, message);	}	synchronized public void fireOnAdminMessage(Message message) {		for (FixClientSimListener listener : listeners)			listener.onAdminMessage(this, message);	}	synchronized public void addListener(FixClientSimListener listener) {		listeners.add(listener);	}	synchronized public void removeListener(FixClientSimListener listener) {		listeners.remove(listener);	}	synchronized public void fireOnLogon() {		state = CONNECTED;		for (FixClientSimListener listener : listeners)			listener.onLogon(this);	}	synchronized public void fireOnLogout() {		state = DISCONNECTED;		for (FixClientSimListener listener : listeners)			listener.onLogout(this);	}	synchronized public boolean isConnected() {		return state == CONNECTED;	}	synchronized public byte getState() {		return state;	}	synchronized protected void close() throws IOException {		initiator.stop(true);		session.disconnect("user requested", false);	}	public long getUid() {		return uid;	}}