package com.f1.console.impl;import java.lang.Thread.State;import java.lang.management.LockInfo;import java.lang.management.ManagementFactory;import java.lang.management.MonitorInfo;import java.lang.management.ThreadInfo;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import com.f1.console.ConsoleConnection;import com.f1.console.ConsoleSession;import com.f1.utils.AH;import com.f1.utils.CH;import com.f1.utils.EH;import com.f1.utils.OH;import com.f1.utils.SH;import com.f1.utils.TextMatcher;import com.f1.utils.concurrent.HasherMap;import com.f1.utils.impl.TextMatcherFactory;import com.f1.utils.structs.BasicMultiMap;public class ShowThreadsConsoleService extends AbstractConsoleService {	private static final Thread.State[] STATES = new Thread.State[] { Thread.State.WAITING, Thread.State.TIMED_WAITING, Thread.State.NEW, Thread.State.BLOCKED,			Thread.State.TERMINATED, Thread.State.RUNNABLE };	private static final Comparator<Map.Entry<String, List<String>>> SORTER = new Comparator<Map.Entry<String, List<String>>>() {		@Override		public int compare(Entry<String, List<String>> o1, Entry<String, List<String>> o2) {			return OH.compare(o1.getValue().size(), o2.getValue().size());		}	};	public ShowThreadsConsoleService() {		super("show threads", "SHOW +THREADS(?: +(.+))?", "displays Threads. Usage: show threads [search_expression]");	}	@Override	public void doRequest(ConsoleSession session, String[] options) {		synchronized (this) {			HasherMap<Thread.State, BasicMultiMap.List<String, String>> stacksToThreads = new HasherMap<Thread.State, BasicMultiMap.List<String, String>>();			String or = AH.getOr(options, 1, null);			if (or == null) {				session.getConnection().println("Please provide a pattern to search for, EX: SHOW THREADS *");				return;			}			TextMatcher matcher = TextMatcherFactory.DEFAULT.toMatcher(or);			ConsoleConnection out = session.getConnection();			StringBuilder sb = new StringBuilder();			for (Thread t : EH.getAllThreads()) {				ThreadInfo info = ManagementFactory.getThreadMXBean().getThreadInfo(t.getId());				final String text = toString(t, info, SH.clear(sb)).toString();				if (matcher.matches(text)) {					HasherMap.Entry<State, com.f1.utils.structs.BasicMultiMap.List<String, String>> s = stacksToThreads.getOrCreateEntry(info == null ? Thread.State.NEW							: info									.getThreadState());					if (s.getValue() == null)						s.setValue(new BasicMultiMap.List<String, String>());					s.getValue().putMulti(text, t.getName());				}			}			for (Thread.State state : STATES) {				if (stacksToThreads.containsKey(state)) {					out.println("______________________________________" + SH.repeat('_', state.toString().length()) + "______________________________________");					out.println("####################################  " + state + "  ####################################");					List<Entry<String, List<String>>> values = CH.l(stacksToThreads.get(state).entrySet());					Collections.sort(values, SORTER);					for (Entry<String, List<String>> i : values) {						List<String> threadNames = i.getValue();						if (threadNames.size() == 1)							out.println(threadNames.get(0) + i.getKey());						else {							SH.clear(sb);							String prefix = SH.commonPrefix(i.getValue());							String suffix = SH.commonSuffix(i.getValue());							if (prefix.endsWith(threadNames.get(0))) {								sb.append(threadNames.size()).append(" Threads (Named ").append(prefix).append(")").append(i.getKey());								sb.append("Distinct Thread Names: ");								boolean first = true;							} else {								sb.append(threadNames.size()).append(" Threads (Named ").append(prefix).append("...").append(suffix).append(")").append(i.getKey());								sb.append("Distinct Thread Names: ");								boolean first = true;								for (String s : i.getValue()) {									if (!first)										sb.append(",");									else										first = false;									sb.append("'");									sb.append(SH.strip(s, prefix, suffix, true));									sb.append("'");								}							}							sb.append(SH.NEWLINE);							out.println(sb);						}					}				}			}		}	}	public static String toString(Thread t) {		ThreadInfo info = ManagementFactory.getThreadMXBean().getThreadInfo(t.getId());		return toString(t, info, new StringBuilder(t.toString())).append(SH.NEWLINE).toString();	}	public static StringBuilder toString(Thread t, ThreadInfo info, StringBuilder sb) {		sb.append(t.isDaemon() ? "(daemon) " : "(non-daemon) ").append(t.getState()).append(SH.NEWLINE);		if (info != null) {			LockInfo li = info.getLockInfo();			if (li != null)				sb.append(" -- Blocked -- (" + li.getClassName() + ") " + li.getIdentityHashCode() + (info.getBlockedTime() >= 0 ? " for " + info.getBlockedTime() + " ms" : ""))						.append(SH.NEWLINE);			for (MonitorInfo mi : info.getLockedMonitors())				sb.append(" -- Monitor -- (" + mi.getClassName() + ") " + mi.getIdentityHashCode()).append(SH.NEWLINE);			for (LockInfo l : info.getLockedSynchronizers())				sb.append(" -- Lock on -- (" + l.getClassName() + ") " + l.getIdentityHashCode()).append(SH.NEWLINE);		}		StackTraceElement[] stes = t.getStackTrace();		for (StackTraceElement ste : stes)			sb.append("  > " + ste).append(SH.NEWLINE);		return sb;	}}