package com.f1.utils;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Set;public class OneToOne<K, V> implements Iterable<Map.Entry<K, V>> {	final private Map<K, V> keyToValue;	final private Map<V, K> valueToKey;	public OneToOne(Map<K, V> keyToValueMap) {		this.keyToValue = keyToValueMap;		this.valueToKey = new HashMap<V, K>();		for (Entry<K, V> i : this.keyToValue.entrySet()) {			V value = i.getValue();			if (valueToKey.containsKey(value))				throw new RuntimeException("value already exists: " + value);			this.valueToKey.put(value, i.getKey());		}	}	public OneToOne(Map<K, V> keyToValueMap, Map<V, K> valueToKeyMap) {		this.keyToValue = keyToValueMap;		this.valueToKey = valueToKeyMap;		if (keyToValueMap.size() != valueToKeyMap.size())			throw new RuntimeException("size mismatch: " + keyToValueMap.size() + " != " + valueToKeyMap.size());		for (Entry<K, V> i : this.keyToValue.entrySet())			if (OH.ne(valueToKey.get(i.getValue()), i.getKey()))				throw new RuntimeException("value mismatch: " + valueToKey.get(i.getValue()) + " != " + i.getKey());	}	public OneToOne() {		this.keyToValue = new HashMap<K, V>();		this.valueToKey = new HashMap<V, K>();	}	public V getValue(K key) {		return keyToValue.get(key);	}	public K getKey(V value) {		return valueToKey.get(value);	}	public boolean put(K key, V value) {		if (keyToValue.containsKey(key)) {			V existingValue = keyToValue.get(key);			if (OH.eq(value, existingValue))				return false;			else				throw new RuntimeException("existing key/value " + key + "=" + existingValue + " being replaced with " + value);		}		if (valueToKey.containsKey(value))			throw new RuntimeException("value already exists: " + value);		keyToValue.put(key, value);		valueToKey.put(value, key);		return true;	}	public boolean putIfAbsent(K key, V value) {		if (keyToValue.containsKey(key))			return false;		if (valueToKey.containsKey(value))			return false;		keyToValue.put(key, value);		valueToKey.put(value, key);		return true;	}	public V removeByKey(K key) {		if (!keyToValue.containsKey(key))			return null;		V value = keyToValue.remove(key);		valueToKey.remove(value);		return value;	}	public V removeByKeyOrThrow(K key) {		if (!keyToValue.containsKey(key))			throw new DetailedException("key not found: " + key).set("key", key).set("existing keys", keyToValue.keySet());		V value = keyToValue.remove(key);		valueToKey.remove(value);		return value;	}	public K removeByValue(V value) {		if (!valueToKey.containsKey(value))			return null;		K key = valueToKey.remove(value);		keyToValue.remove(key);		return key;	}	public K removeByValueOrThrow(V value) {		if (!valueToKey.containsKey(value))			throw new DetailedException("value not found: " + value).set("value", value).set("existing values", valueToKey.keySet());		K key = valueToKey.remove(value);		keyToValue.remove(key);		return key;	}	public Set<K> getKeys() {		return keyToValue.keySet();	}	public Set<V> getValues() {		return valueToKey.keySet();	}	public void clear() {		keyToValue.clear();		valueToKey.clear();	}	@Override	public String toString() {		return keyToValue.toString();	}	@Override	public Iterator<Entry<K, V>> iterator() {		return keyToValue.entrySet().iterator();	}	public Set<Entry<K, V>> getEntries() {		return keyToValue.entrySet();	}	public Set<Entry<V, K>> getEntriesByValue() {		return valueToKey.entrySet();	}	public Map<V, K> toValueKeyMap() {		return new HashMap<V, K>(valueToKey);	}	public Map<K, V> toKeyValueMap() {		return new HashMap<K, V>(keyToValue);	}	public Map<V, K> getInnerValueKeyMap() {		return valueToKey;	}	public Map<K, V> getInnerKeyValueMap() {		return keyToValue;	}	public int size() {		return keyToValue.size();	}	public void putAll(Map<? extends K, ? extends V> map) {		for (Entry<? extends K, ? extends V> e : map.entrySet())			put(e.getKey(), e.getValue());	}	public static OneToOne create(Object... keyValue) {		if (keyValue.length % 2 != 0)			throw new RuntimeException("Expecting key value pairs:" + keyValue.length);		OneToOne<Object, Object> r = new OneToOne();		for (int i = 0; i < keyValue.length;)			r.put(keyValue[i++], keyValue[i++]);		return r;	}	public boolean containsKey(Object key) {		return this.keyToValue.containsKey(key);	}	public boolean containsValue(Object value) {		return this.valueToKey.containsKey(value);	}}