package com.f1.utils;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.HashSet;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;import java.util.TreeMap;import java.util.TreeSet;import com.f1.base.Legible;import com.f1.base.Lockable;import com.f1.base.LockedException;import com.f1.base.ToStringable;import com.f1.utils.impl.BasicCharMatcher;import com.f1.utils.impl.BasicPropertyController;import com.f1.utils.impl.StringCharReader;import com.f1.utils.impl.TextMatcherFactory;import com.f1.utils.structs.BasicMultiMap;import com.f1.utils.structs.table.BasicTable;public class ArgParser implements ToStringable, Legible, Lockable {	public static final String DEFAULT_LONG_PREFIX = "--";	public static final String DEFAULT_SHORT_PREFIX = "-";	private static final char DEFAULT_DELIM = '=';	private final Map<String, Switch> options = new TreeMap<String, Switch>();	private final Map<String, Switch> switchesById = new HashMap<String, Switch>();	private final List<Switch> requiredSwitches = new ArrayList<Switch>();	private final List<Switch> optionalSwitches = new ArrayList<Switch>();	private final Set<String> longSwitches = new TreeSet<String>();	private final Set<String> shortSwitches = new TreeSet<String>();	private String description = "";	private int requiredCount = 0;	private char delim;	private boolean isLocked;	final private String longNamePrefix;	final private String shortNamePrefix;	private int nextId = 0;	private int[] __eofDelimOrSpace;	public ArgParser(char delim, String shortNamePrefix, String longNamePrefix, String description) {		this.delim = delim;		this.description = description;		this.shortNamePrefix = shortNamePrefix;		this.longNamePrefix = longNamePrefix;		__eofDelimOrSpace = new int[] { CharReader.EOF, delim, ' ' };	}	public ArgParser(String description) {		this(DEFAULT_DELIM, DEFAULT_SHORT_PREFIX, DEFAULT_LONG_PREFIX, description);	}	public ArgParser addSwitchOptional(String shortName, String longName, String matchExpression, String description) {		return addSwitch(shortName, longName, TextMatcherFactory.DEFAULT.toMatcher(matchExpression), false, false, description);	}	public ArgParser addSwitchRequired(String shortName, String longName, String matchExpression, String description) {		return addSwitch(shortName, longName, TextMatcherFactory.DEFAULT.toMatcher(matchExpression), false, true, description);	}	public ArgParser addSwitch(String shortName, String longName, TextMatcher validator, boolean allowMultiple, boolean required, String description) {		shortName = shortName == null ? null : shortNamePrefix + shortName;		longName = longName == null ? null : longNamePrefix + longName;		if (isLocked())			throw new LockedException();		if (allowMultiple) {		}		Switch option = new Switch(nextId++, shortName, longName, validator, allowMultiple, required, description);		if (option.getRequired())			requiredCount++;		if (option.getShortKey() != null) {			CH.putOrThrow(options, option.getShortKey(), option);			this.shortSwitches.add(option.getShortKey());		}		if (option.getLongKey() != null) {			CH.putOrThrow(options, option.getLongKey(), option);			this.longSwitches.add(option.getLongKey());		}		if (required) {			requiredSwitches.add(option);			Collections.sort(requiredSwitches);		} else {			optionalSwitches.add(option);			Collections.sort(optionalSwitches);		}		switchesById.put(option.getId(), option);		return this;	}	public List<Switch> getRequiredSwitches() {		return this.requiredSwitches;	}	public List<Switch> getOptionalSwitches() {		return this.optionalSwitches;	}	public Set<String> getOptions() {		return options.keySet();	}	public Set<String> getShortOptions() {		return shortSwitches;	}	public Set<String> getLongOptions() {		return longSwitches;	}	public char getDelim() {		return delim;	}	public Switch getOption(String key) {		return CH.getOrThrow(options, key);	}	public String getHelp(String key) {		return options.get(key).getDescription();	}	public Arguments parseNoThrow(String[] text) {		quoteIfNecessary(text);		return parseNoThrow(SH.join(' ', text));	}	public Arguments parse(String[] text) {		quoteIfNecessary(text);		return parse(SH.join(' ', text));	}	private void quoteIfNecessary(String[] text) {		for (int i = 0; i < text.length; i++)			text[i] = SH.escape(text[i], ' ', '\\');	}	public Arguments parseNoThrow(String text) {		try {			return parse(text);		} catch (DetailedException e) {			System.err.println(toLegibleString());			System.err.println();			System.err.println("   -----  See errors Below -----");			System.err.println();			System.err.println();			System.err.println(e.toLegibleString());			return null;		} catch (Exception e) {			System.err.println(toLegibleString());			System.err.println();			System.err.println("   -----  See errors Below -----");			System.err.println();			System.err.println();			System.err.println(e.getMessage());			return null;		}	}	public Arguments parse(String text) {		final BasicMultiMap.List<String, String> r = new BasicMultiMap.List<String, String>();		final List<String> others = new ArrayList<String>();		r.setInnerMap(new LinkedHashMap<String, List<String>>());		final CharReader s = new StringCharReader(text);		final StringBuilder tmp = new StringBuilder();		int requiredSuppliedCount = 0;		String key = null, val = null;		W: while (true) {			s.skip(' ');			int c = s.peakOrEof();			switch (c) {				case CharReader.EOF:					if (key != null) {						val = "";						break;					} else						break W;				case '"':				case '\'':					s.expect((char) c);					s.readUntilSkipEscaped(c, '\\', SH.clear(tmp));					val = tmp.toString();					s.expect((char) c);					break;				default:					if (key == null && (s.peakSequence(shortNamePrefix) || s.peakSequence(longNamePrefix))) {						int i = s.readUntilAny(__eofDelimOrSpace, SH.clear(tmp));						if (i != CharReader.EOF)							s.expect(i);						if (i == delim) {							key = tmp.toString();						} else {							key = tmp.toString();							val = "";						}					} else {						s.readUntilAnySkipEscaped(new BasicCharMatcher(" ", true), '\\', SH.clear(tmp));						val = tmp.toString();					}			}			if (val != null) {				if (key == null) {					final Switch option = options.get(val);					if (option != null) {						key = val;						val = "";					}				}				if (key == null)					others.add(val);				else {					Switch option = CH.getOrThrow(options, key, "invalid option");					if (!option.isValid(val))						throw new IllegalArgumentException("Syntax error (for value): " + key + delim + val);					final String existing = r.getMulti(option.getId());					if (existing != null) {						if (!option.getAllowMultiple())							throw new IllegalArgumentException("Option repeated: " + key + delim + existing + "  --and-- " + key + delim + val);					} else if (option.getRequired())						requiredSuppliedCount++;					r.putMulti(option.getId(), val);				}				val = key = null;			}		}		if (requiredSuppliedCount != requiredCount) {			final List<Switch> missing = new ArrayList<Switch>();			for (Switch o : switchesById.values()) {				if (!o.getRequired())					continue;				if (r.containsKey(o.getId()))					continue;				if (missing.contains(o))					continue;				missing.add(o);			}			throw new DetailedException("Required options missing").set("supplied text", text).set("missing options", missing);		}		Properties properties = new Properties();		for (Map.Entry<String, List<String>> e : r.entrySet()) {			Switch k = switchesById.get(e.getKey());			if (k.allowMultiple)				properties.put(k.getId(), e.getValue());			else				properties.put(k.getId(), e.getValue().get(0));		}		return new Arguments(properties, others);	}	public void setDescription(String description) {		if (isLocked())			throw new LockedException();		this.description = description;	}	public String getDescription() {		return description;	}	@Override	public String toString() {		return toString(new StringBuilder()).toString();	}	@Override	public StringBuilder toString(StringBuilder sb) {		sb.append(description).append(": ");		SH.join(", ", options.values(), sb);		return sb;	}	@Override	public String toLegibleString() {		BasicTable table = new BasicTable(String.class, "short", String.class, "long", String.class, "description");		Set<String> printed = new HashSet<String>();		StringBuilder sb = new StringBuilder();		sb.append(description).append(SH.NEWLINE);		if (!requiredSwitches.isEmpty()) {			for (Switch o : requiredSwitches) {				String key = o.getShortKey();				if (key == null)					key = o.getLongKey();				if (!printed.add(key))					continue;				table.getRows().addRow(SH.noNull(o.getShortKey()), "  " + SH.noNull(o.getLongKey()), "  ==>  " + o.getDescription());			}			sb.append(SH.NEWLINE).append("  Required Arguments:").append(SH.NEWLINE);			TableHelper.toString(table, "    ", 0, sb, SH.NEWLINE, ' ', ' ', ' ');			table.clear();		}		for (Switch o : optionalSwitches) {			String key = o.getShortKey();			if (key == null)				key = o.getLongKey();			if (!printed.add(key))				continue;			table.getRows().addRow(SH.noNull(o.getShortKey()), "  " + SH.noNull(o.getLongKey()), "  ==>  " + o.getDescription());		}		if (!optionalSwitches.isEmpty()) {			sb.append(SH.NEWLINE).append("  Optional Arguments:").append(SH.NEWLINE);			TableHelper.toString(table, "    ", 0, sb, SH.NEWLINE, ' ', ' ', ' ');		}		return sb.toString();	}	public class Switch implements ToStringable, Comparable<Switch> {		private final String shortKey;		private final String longKey;		private final TextMatcher validator;		private final boolean required;		private final boolean allowMultiple;		private final String description;		private String id;		public Switch(int id, String shortKey, String longKey, TextMatcher validator, boolean allowMultiple, boolean required, String description) {			if (description == null)				throw new NullPointerException("description");			if (shortKey == null && longKey == null)				throw new IllegalArgumentException("short and long key are both null for: " + description);			this.shortKey = shortKey;			this.longKey = longKey;			this.validator = validator;			this.required = required;			this.allowMultiple = allowMultiple;			this.description = description;			this.id = this.shortKey == null ? SH.stripPrefix(this.longKey, longNamePrefix, true) : SH.stripPrefix(this.shortKey, shortNamePrefix, true);		}		public String getId() {			return id;		}		public boolean isValid(String text) {			return validator.matches(text);		}		@Override		public String toString() {			return toString(new StringBuilder()).toString();		}		@Override		public StringBuilder toString(StringBuilder sb) {			if (getShortKey() != null)				sb.append(getShortKey()).append(' ');			if (getLongKey() != null)				sb.append(getLongKey()).append(' ');			sb.append(" ==>");			sb.append(getDescription());			if (required && allowMultiple)				sb.append(" (required,multiple)");			else if (allowMultiple)				sb.append(" (multiple)");			else if (required)				sb.append(" (required)");			return sb;		}		public String getDescription() {			return description;		}		public String getShortKey() {			return shortKey;		}		public String getLongKey() {			return longKey;		}		public boolean getAllowMultiple() {			return allowMultiple;		}		public boolean getRequired() {			return required;		}		@Override		public int compareTo(Switch o) {			return OH.compare(OH.noNull(shortKey, longKey), OH.noNull(o.shortKey, o.longKey));		}		@Override		public boolean equals(Object obj) {			return obj instanceof Switch && compareTo((Switch) obj) == 0;		}	}	@Override	public void lock() {		isLocked = true;	}	@Override	public boolean isLocked() {		return isLocked;	}	public static class Arguments extends BasicPropertyController implements ToStringable {		private List<String> args;		public Arguments(Properties properties, List<String> args) {			super(properties);			this.args = args;		}		public boolean hasOption(String key) {			return getProperties().containsKey(key);		}		public List<String> getAdditionalArguments() {			return this.args;		}		@Override		public StringBuilder toString(StringBuilder sink) {			sink.append("switches: ").append(super.toString());			sink.append(", arguments: [");			SH.join(",", args, sink);			sink.append("]");			return sink;		}		@Override		public String toString() {			return toString(new StringBuilder()).toString();		}		public <T> List<T> getRequiredMulti(String key, Class<T> type) {			Object va = super.getProperties().get(key);			if (va == null)				getRequired(key);//this will throw			List<Object> l;			if (va instanceof List)				l = (List) va;			else				l = CH.l(va);			return CH.castAll(l, type, true);		}	}}