package com.f1.utils.impl;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Set;import com.f1.utils.CH;import com.f1.utils.EnvironmentDump;import com.f1.utils.Labeler;import com.f1.utils.MH;import com.f1.utils.OH;import com.f1.utils.SH;public class BasicLabeler implements Labeler {	private static final String DEFAULT_PREFIX = " ";	private static final String DEFAULT_DELIM = ": ";	private List<LabelEntry> entries = new ArrayList<LabelEntry>();	private Map<String, LabelEntry> labels2entries = new HashMap<String, LabelEntry>();	private LabelEntry currentLabel;	private int maxLabelLength = 0;	private int maxItemLength = 0;	@Override	public void addLabel(String label, boolean reuseIfExists) {		if (label == null)			throw new NullPointerException("label");		if (maxLabelLength < label.length())			maxLabelLength = label.length();		LabelEntry existingLabel = labels2entries.get(label);		if (reuseIfExists && existingLabel != null) {			currentLabel = existingLabel;			return;		}		entries.add(currentLabel = new LabelEntry(LabelEntry.TYPE_LABEL, label));		if (existingLabel == null)			labels2entries.put(label, currentLabel);	}	@Override	public void addDivider(String label) {		entries.add(new LabelEntry(LabelEntry.TYPE_DIV, label));	}	@Override	public void addItem(Object item) {		if (entries.size() == 0)			throw new IllegalStateException("must add at least one label before adding items");		final String s = SH.toString(item);		final int len = s.indexOf('\n');		maxItemLength = Math.max(maxItemLength, len == -1 ? s.length() : len);		entries.get(entries.size() - 1).items.add(s);	}	@Override	public void addItem(String label, Object item, boolean appendIfLabelExists) {		if (currentLabel == null || !currentLabel.label.equals(label))			addLabel(label, appendIfLabelExists);		addItem(item);	}	@Override	public void addItems(String label, List<String> values) {		if (label == null)			throw new NullPointerException("label");		LabelEntry existingLabel = labels2entries.get(label);		if (existingLabel != null) {			currentLabel = existingLabel;			currentLabel.items.addAll(values);		} else {			entries.add(currentLabel = new LabelEntry(LabelEntry.TYPE_LABEL, label, values));			labels2entries.put(label, currentLabel);		}	}	@Override	public String toString(String prefix, String delim, int options) {		final boolean sortLabels = MH.areAnyBitsSet(OPTION_SORT_LABELS, options);		final boolean sortIncludeItemlesslabels = MH.areAnyBitsSet(OPTION_INCLUDE_ITEMLESS_LABELS, options);		final boolean repeatLabels = MH.areAnyBitsSet(OPTION_REPEAT_LABELS, options);		final boolean leftAlign = MH.areAnyBitsSet(OPTION_LEFT_ALIGN, options);		final boolean hidePasswords = MH.areAnyBitsSet(OPTION_HIDE_PASSWORDS, options);		final List<LabelEntry> entries2 = sortLabels ? CH.sort(entries) : entries;		final String padding = SH.repeat(' ', maxLabelLength + delim.length(), new StringBuilder(prefix)).toString();		final StringBuilder sb = new StringBuilder();		int divLength = maxItemLength + maxLabelLength + delim.length() + 1;		for (LabelEntry e : entries2) {			boolean isPassword = hidePasswords && EnvironmentDump.isPasswordKey(e.label);			String label = leftAlign ? (e.label + delim) : SH.rightAlign(' ', e.label, maxLabelLength, false, new StringBuilder(prefix)).append(delim).toString();			if (e.type == LabelEntry.TYPE_DIV) {				if (SH.is(e.label)) {					int t = (divLength - e.label.length() - 4);					if (t < 4)						t = 4;					sb.append(prefix);					SH.repeat('-', t / 2, sb);					sb.append("( ").append(e.label).append(" )");					SH.repeat('-', t / 2 + (t % 2), sb);					sb.append(SH.NEWLINE);				} else {					SH.repeat('-', divLength, sb.append(prefix)).append(SH.NEWLINE);				}			} else if (e.items.size() == 0) {				if (!sortIncludeItemlesslabels)					continue;				sb.append(label).append(SH.NEWLINE);			} else {				String item = e.items.get(0);				if (isPassword)					item = SH.password(item);				sb.append(label).append(SH.prefixLines(item, padding, false)).append(SH.NEWLINE);				if (!repeatLabels)					label = padding;				for (int i = 1; i < e.items.size(); i++) {					item = e.items.get(i);					if (isPassword)						item = SH.password(item);					sb.append(label).append(SH.prefixLines(item, padding, false)).append(SH.NEWLINE);				}			}		}		return sb.toString();	}	@Override	public String toString() {		return toString(DEFAULT_PREFIX, DEFAULT_DELIM, 0);	}	private static class LabelEntry implements Comparable<LabelEntry> {		public static final byte TYPE_LABEL = 1;		public static final byte TYPE_DIV = 2;		final public String label;		final public byte type;		final public List<String> items;		public LabelEntry(byte type, String label) {			this.type = type;			this.label = label;			this.items = new ArrayList<String>(1);		}		public LabelEntry(byte type, String label, List<String> values) {			this.type = type;			this.label = label;			this.items = new ArrayList<String>(values);		}		@Override		public int compareTo(LabelEntry o) {			return SH.COMPARATOR_CASEINSENSITIVE.compare(label, o.label);		}		@Override		public boolean equals(Object o) {			return o != null && o.getClass() == this.getClass() && compareTo((LabelEntry) o) == 0;		}		@Override		public int hashCode() {			return OH.hashCode(label, items);		}	}	@Override	public void addItem(String label, Object item) {		addItem(label, item, true);	}	@Override	public Set<String> getLabels() {		return this.labels2entries.keySet();	}	@Override	public List<String> getItems(String label_) {		return this.labels2entries.get(label_).items;	}}