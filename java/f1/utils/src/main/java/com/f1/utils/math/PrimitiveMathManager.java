package com.f1.utils.math;import java.util.HashMap;import java.util.Map;import com.f1.utils.CH;import com.f1.utils.OH;public class PrimitiveMathManager {	public static final PrimitiveMathManager INSTANCE = new PrimitiveMathManager(BigDecimalMath.INSTANCE, new BigIntMath(), new ByteMath(), new DoubleMath(), new FixPointMath(),			new FloatMath(), new IntMath(), new LongMath(), new ShortMath(), new DateMillisMath(), new DateNanosMath(), new ComplexMath());	private Map<Class, PrimitiveMath> maths = new HashMap<Class, PrimitiveMath>();	public PrimitiveMathManager(PrimitiveMath... maths) {		for (PrimitiveMath math : maths)			CH.putOrThrow(this.maths, math.getReturnType(), math);	}	public PrimitiveMath get(Class c) {		if (c.isPrimitive())			c = OH.getBoxed(c);		return CH.getOrThrow(maths, c);	}	public PrimitiveMath getNoThrow(Class c) {		if (c == null)			return null;		if (c.isPrimitive())			c = OH.getBoxed(c);		return CH.getOr(maths, c, null);	}	public PrimitiveMath get(Number l, Number r) {		return get(OH.getWidest(l.getClass(), r.getClass()));	}	public PrimitiveMath get(Class<? extends Number> l, Class<? extends Number> r) {		return get(OH.getWidest(l, r));	}	public PrimitiveMath getNoThrow(Number l, Number r) {		if (l == null || r == null)			return null;		return getNoThrow(OH.getWidest(l.getClass(), r.getClass()));	}	public PrimitiveMath getNoThrow(Class<? extends Number> l, Class<? extends Number> r) {		if (l == null || r == null)			return null;		return getNoThrow(OH.getWidest(l, r));	}	public Object eval(Number l, Number r, String operation) {		return eval(get(l, r), l, r, operation);	}	public Object eval(PrimitiveMath math, Number l, Number r, String operation) {		if (l == null || r == null)			return null;		int length = operation.length();		switch (operation.charAt(0)) {			case '+':				if (length == 1)					return math.add(l, r);				break;			case '-':				if (length == 1)					return math.subtract(l, r);				break;			case '*':				if (length == 1)					return math.multiply(l, r);				break;			case '/':				if (length == 1)					return math.divide(l, r);				break;			case '%':				if (length == 1)					return math.mod(l, r);				break;			case '!':				if (length == 2 && operation.charAt(1) == '=')					return math.compare(l, r) != 0;				break;			case '=':				if (length == 2 && operation.charAt(1) == '=')					return math.compare(l, r) == 0;				break;			case '>':				switch (length) {					case 1:						return math.compare(l, r) > 0;					case 2:						switch (operation.charAt(1)) {							case '=':								return math.compare(l, r) >= 0;							case '>':								return ((PrimitiveBitwiseMath<Number>) math).shiftRight(l, r);						}						break;					case 3:						if (operation.charAt(1) == '>' && operation.charAt(2) == '>')							return ((PrimitiveBitwiseMath<Number>) math).shiftRightUnsigned(l, r);						break;				}				break;			case '<':				switch (length) {					case 1:						return math.compare(l, r) < 0;					case 2:						switch (operation.charAt(1)) {							case '=':								return math.compare(l, r) <= 0;							case '<':								return ((PrimitiveBitwiseMath) math).shiftLeft(l, r);						}						break;				}				break;			case 'm':				if ("max".equals(operation))					return math.compare(l, r) > 0 ? l : r;				if ("min".equals(operation))					return math.compare(l, r) < 0 ? l : r;			default:		}		throw new RuntimeException("unknown operation: '" + operation + "'");	}}