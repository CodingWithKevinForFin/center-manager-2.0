package com.f1.utils.string;import com.f1.base.Legible;import com.f1.utils.MH;import com.f1.utils.OH;import com.f1.utils.SH;import com.f1.utils.structs.Tuple2;public class ExpressionParserException extends RuntimeException implements Legible {	final private int position;	private boolean isRuntime;	private String expression;	public ExpressionParserException(int position, String message_, Throwable cause_) {		super(message_, cause_);		this.position = position;		if (cause_ instanceof ExpressionParserException && ((ExpressionParserException) cause_).getisRuntime())			setIsRuntime();	}	public ExpressionParserException(int position, String message_) {		super(message_);		this.position = position;	}	public ExpressionParserException(String expression, int position, String message_, Throwable cause_) {		super(message_, cause_);		this.expression = expression;		this.position = position;		if (cause_ instanceof ExpressionParserException && ((ExpressionParserException) cause_).getisRuntime())			setIsRuntime();	}	public ExpressionParserException(String expression, int position, String message_) {		super(message_);		this.expression = expression;		this.position = position;	}	public int getPosition() {		return position;	}	public String getExpression() {		return expression;	}	public boolean getisRuntime() {		return this.isRuntime;	}	public ExpressionParserException setIsRuntime() {		this.isRuntime = true;		return this;	}	public void setExpression(String expression) {		if (this.expression != null && OH.ne(this.expression, expression))			throw new IllegalStateException("Expression already set");		this.expression = expression;	}	public String toLegibleStringBefore() {		StringBuilder sb = new StringBuilder();		if (expression != null) {			Tuple2<Integer, Integer> pos = SH.getLinePosition(expression, getPosition());			sb.append("Error At Line ").append(pos.getA().intValue() + 1).append(", position ").append(pos.getB()).append(':').append(SH.NEWLINE);			String[] lines = SH.splitLines(expression, false);			int padding = MH.getDigitsCount(lines.length, 10);			for (int i = 0; i < lines.length; i++) {				sb.append(' ');				SH.rightAlign('0', SH.toString(i + 1), padding, false, sb).append(": ").append(lines[i]).append(SH.NEWLINE);				if (i == pos.getA().intValue()) {					break;				}			}		}		return sb.toString();	}	public String toLegibleStringException(boolean useExtendedAscii) {		StringBuilder sb = new StringBuilder();		boolean printedError = false;		if (expression != null) {			Tuple2<Integer, Integer> pos = SH.getLinePosition(expression, getPosition());			String[] lines = SH.splitLines(expression, false);			for (int i = 0; i < lines.length; i++)				lines[i] = SH.trimTrailingWhitespace(lines[i]);			int padding = MH.getDigitsCount(lines.length, 10);			int longestExpressionLength = Math.max(SH.getLongest(lines).length(), pos.getB()) + padding + 1;			String m = getMessage();			if (m == null)				m = "";			m = SH.replaceAll(m, '\t', "  ");			String[] msgLines = SH.splitLines(m);			for (int i = 0; i < msgLines.length; i++)				msgLines[i] = SH.trimTrailingWhitespace(msgLines[i]);			msgLines = SH.splitLongLines(msgLines, 160, true);			int arrowPos = Math.max(0, padding + 3 + pos.getB().intValue());			int pad = arrowPos + 3;			int len = msgLines.length == 0 ? 0 : SH.getLongest(msgLines).length();			if (pad + len > longestExpressionLength)				pad = longestExpressionLength - len - 1;			if (pad < 4)				pad = 4;			if (useExtendedAscii) {				if (arrowPos < pad) {					SH.repeat(' ', arrowPos, sb).append("└");					SH.repeat('─', pad - arrowPos - 1, sb).append("┬");					SH.repeat('─', len + 2, sb);				} else if (arrowPos == pad) {					SH.repeat(' ', arrowPos, sb).append("├");					SH.repeat('─', len + 2, sb);				} else {					SH.repeat(' ', pad, sb).append("┌");					for (int i = 0; i < len + 2; i++)						sb.append(i + pad + 1 == arrowPos ? '┴' : '─');				}				sb.append(arrowPos == pad + len + 3 ? '┤' : '┐').append(SH.NEWLINE);				for (int n = 0; n < msgLines.length; n++) {					SH.repeat(' ', pad, sb).append("│ ");					SH.ddd(SH.leftAlign(' ', msgLines[n], len, false), 180, sb).append(" │");					sb.append(SH.NEWLINE);				}				SH.repeat(' ', pad, sb).append("└─");				SH.repeat('─', len + 1, sb).append("┘").append(SH.NEWLINE);			} else {				SH.repeat(' ', arrowPos - 1, sb).append("/|\\").append(SH.NEWLINE);				if (arrowPos < pad) {					SH.repeat(' ', arrowPos, sb).append("+");					SH.repeat('-', pad - arrowPos - 1, sb).append("+");					SH.repeat('-', len + 2, sb);				} else if (arrowPos == pad) {					SH.repeat(' ', arrowPos, sb).append("+");					SH.repeat('-', len + 2, sb);				} else {					SH.repeat(' ', pad, sb).append("+");					for (int i = 0; i < len + 2; i++)						sb.append(i + pad + 1 == arrowPos ? '+' : '-');				}				sb.append('+').append(SH.NEWLINE);				for (int n = 0; n < msgLines.length; n++) {					SH.repeat(' ', pad, sb).append("| ");					SH.ddd(SH.leftAlign(' ', msgLines[n], len, false), 180, sb).append(" |");					sb.append(SH.NEWLINE);				}				SH.repeat(' ', pad, sb).append("+-");				SH.repeat('-', len + 1, sb).append("+").append(SH.NEWLINE);			}			printedError = true;		}		if (!printedError) {			sb.append(" Error: ").append(getMessage()).append(" At Position: ").append(getPosition()).append(SH.NEWLINE);		}		return sb.toString();	}	public String toLegibleStringAfter() {		StringBuilder sb = new StringBuilder();		if (expression != null) {			Tuple2<Integer, Integer> pos = SH.getLinePosition(expression, getPosition());			String[] lines = SH.splitLines(expression, false);			int padding = MH.getDigitsCount(lines.length, 10);			for (int i = pos.getA().intValue() + 1; i < lines.length; i++) {				sb.append(' ');				SH.rightAlign('0', SH.toString(i + 1), padding, false, sb).append(": ").append(lines[i]).append(SH.NEWLINE);			}		}		return sb.toString();	}	@Override	public String toLegibleString() {		return toLegibleStringBefore() + toLegibleStringException(false) + toLegibleStringAfter();	}	public String getMessageRecurse() {		Throwable c = getCause();		if (c == null || c == this)			return this.getMessage();		String inner;		if (c instanceof ExpressionParserException) {			inner = ((ExpressionParserException) c).getMessageRecurse();		} else {			inner = c.getMessage();		}		if (SH.isnt(inner))			return this.getMessage();		String[] lines = SH.splitLines(inner);		StringBuilder sb = new StringBuilder(getMessage()).append(" ==> ").append(SH.NEWLINE);		for (String s : lines)			sb.append("  ").append(s).append(SH.CHAR_NEWLINE);		return sb.toString();	}}