package com.f1.utils.impl;import java.lang.reflect.Array;import java.util.Arrays;import java.util.Iterator;import java.util.NoSuchElementException;import com.f1.base.IterableAndSize;import com.f1.base.ToStringable;import com.f1.utils.Reiterable;import com.f1.utils.SH;public class FastArrayList<T> implements Reiterable<T>, ToStringable, IterableAndSize<T> {	public class Iter implements Iterator<T> {		private int i = 0;		public Iter() {		}		@Override		public boolean hasNext() {			return i < size;		}		@Override		public T next() throws NoSuchElementException {			return (T) elements[i++];		}		@Override		public void remove() {			FastArrayList.this.remove(--i);		}		public void reset() {			i = 0;		}	}	private T[] elements;	private int size;	public FastArrayList(T[] data, int initialSize) {		elements = data;		this.size = initialSize;	}	public void clear(int maxCapacity) {		if (this.elements.length > maxCapacity) {			this.elements = (T[]) Array.newInstance(this.elements.getClass().getComponentType(), maxCapacity);			this.size = 0;		} else {			for (int i = size - 1; i >= 0; i--)				this.elements[size] = null;			this.size = 0;		}	}	public FastArrayList(int initialSize) {		elements = (T[]) new Object[initialSize];	}	public FastArrayList(IterableAndSize<T> values) {		elements = (T[]) new Object[values.size()];		int n = 0;		for (T i : values)			elements[n++] = i;	}	public FastArrayList(Object[] array) {		this.elements = (T[]) array;		this.size = array.length;	}	public void add(T element) {		ensureCapacity(size + 1);		elements[size++] = element;	}	public void remove(int i) {		assertIndex(i);		size--;		for (int j = i; j < size; j++)			elements[j] = elements[j + 1];		elements[size] = null;	}	public T get(int i) {		assertIndex(i);		return elements[i];	}	public void set(int i, T obj) {		assertIndex(i);		elements[i] = obj;	}	private void assertIndex(int i) {		if (i < 0 || i >= size)			throw new IndexOutOfBoundsException("size: " + size + " index: " + i);	}	private void ensureCapacity(int size) {		if (size >= elements.length)			elements = Arrays.copyOf(elements, elements.length * 2);	}	@Override	public Iterator<T> iterator() {		return new Iter();	}	@Override	public Iterator<T> iterator(Iterator<T> iterator) {		((Iter) iterator).reset();		return iterator;	}	public int size() {		return size;	}	public void setSize(int size) {		if (size == this.size)			return;		if (size < this.size) {			for (int i = size; i < this.size; i++)				elements[i] = null;			this.size = size;		} else			ensureCapacity(size);		this.size = size;	}	public void setSizeNoCheck(int size) {		this.size = size;	}	@Override	public StringBuilder toString(StringBuilder sb) {		sb.append('[');		if (size > 0)			SH.s(elements[0], sb);		for (int i = 1; i < size; i++)			SH.s(elements[i], sb.append(','));		return sb.append(']');	}	@Override	public String toString() {		return toString(new StringBuilder()).toString();	}	public int indexOfByIdentity(T value) {		for (int i = 0; i < size; i++)			if (elements[i] == value)				return i;		return -1;	}	public T getNoCheck(int index) {		return (T) elements[index];	}	public T[] getElements() {		return this.elements;	}	public void setNoCheck(int i, T obj) {		elements[i] = obj;	}	public void addAll(IterableAndSize<T> e) {		ensureCapacity(size + e.size());		for (T t : e)			elements[size++] = t;	}	public void addAll(Iterable<T> e) {		for (T t : e)			add(t);	}	public void fill(int count, T value) {		int size = this.size;		ensureCapacity(size + count);		while (count-- > 0)			elements[size++] = value;		this.size = size;	}}